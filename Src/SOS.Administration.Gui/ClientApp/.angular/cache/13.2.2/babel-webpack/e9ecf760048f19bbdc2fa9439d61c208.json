{"ast":null,"code":"/* global window, define, module */\n(function (global, factory) {\n  var Gauge = factory(global);\n\n  if (typeof define === \"function\" && define.amd) {\n    // AMD support\n    define(function () {\n      return Gauge;\n    });\n  } else if (typeof module === \"object\" && module.exports) {\n    // CommonJS support\n    module.exports = Gauge;\n  } else {\n    // We are probably running in the browser\n    global.Gauge = Gauge;\n  }\n})(typeof window === \"undefined\" ? this : window, function (global, undefined) {\n  var document = global.document,\n      slice = Array.prototype.slice,\n      requestAnimationFrame = global.requestAnimationFrame || global.mozRequestAnimationFrame || global.webkitRequestAnimationFrame || global.msRequestAnimationFrame || function (cb) {\n    return setTimeout(cb, 1000 / 60);\n  }; // EXPERIMENTAL!!\n\n  /**\n   * Simplistic animation function for animating the gauge. That's all!\n   * Options are:\n   * {\n   *  duration: 1,    // In seconds\n   *  start: 0,       // The start value\n   *  end: 100,       // The end value\n   *  step: function, // REQUIRED! The step function that will be passed the value and does something\n   *  easing: function // The easing function. Default is easeInOutCubic\n   * }\n   */\n\n\n  function Animation(options) {\n    var duration = options.duration,\n        currentIteration = 1,\n        iterations = 60 * duration,\n        start = options.start || 0,\n        end = options.end,\n        change = end - start,\n        step = options.step,\n        easing = options.easing || function easeInOutCubic(pos) {\n      // https://github.com/danro/easing-js/blob/master/easing.js\n      if ((pos /= 0.5) < 1) return 0.5 * Math.pow(pos, 3);\n      return 0.5 * (Math.pow(pos - 2, 3) + 2);\n    };\n\n    function animate() {\n      var progress = currentIteration / iterations,\n          value = change * easing(progress) + start; // console.log(progress + \", \" + value);\n\n      step(value, currentIteration);\n      currentIteration += 1;\n\n      if (progress < 1) {\n        requestAnimationFrame(animate);\n      }\n    } // start!\n\n\n    requestAnimationFrame(animate);\n  }\n\n  var Gauge = function () {\n    var SVG_NS = \"http://www.w3.org/2000/svg\";\n    var GaugeDefaults = {\n      centerX: 50,\n      centerY: 50\n    };\n    var defaultOptions = {\n      dialRadius: 40,\n      dialStartAngle: 135,\n      dialEndAngle: 45,\n      value: 0,\n      max: 100,\n      min: 0,\n      valueDialClass: \"value\",\n      valueClass: \"value-text\",\n      dialClass: \"dial\",\n      gaugeClass: \"gauge\",\n      showValue: true,\n      gaugeColor: null,\n      label: function (val) {\n        return Math.round(val);\n      }\n    };\n\n    function\n      /* source, ...targets*/\n    shallowCopy() {\n      var target = arguments[0],\n          sources = slice.call(arguments, 1);\n      sources.forEach(function (s) {\n        for (var k in s) {\n          if (s.hasOwnProperty(k)) {\n            target[k] = s[k];\n          }\n        }\n      });\n      return target;\n    }\n    /**\n     * A utility function to create SVG dom tree\n     * @param {String} name The SVG element name\n     * @param {Object} attrs The attributes as they appear in DOM e.g. stroke-width and not strokeWidth\n     * @param {Array} children An array of children (can be created by this same function)\n     * @return The SVG element\n     */\n\n\n    function svg(name, attrs, children) {\n      var elem = document.createElementNS(SVG_NS, name);\n\n      for (var attrName in attrs) {\n        elem.setAttribute(attrName, attrs[attrName]);\n      }\n\n      if (children) {\n        children.forEach(function (c) {\n          elem.appendChild(c);\n        });\n      }\n\n      return elem;\n    }\n    /**\n     * Translates percentage value to angle. e.g. If gauge span angle is 180deg, then 50%\n     * will be 90deg\n     */\n\n\n    function getAngle(percentage, gaugeSpanAngle) {\n      return percentage * gaugeSpanAngle / 100;\n    }\n\n    function normalize(value, min, limit) {\n      var val = Number(value);\n      if (val > limit) return limit;\n      if (val < min) return min;\n      return val;\n    }\n\n    function getValueInPercentage(value, min, max) {\n      var newMax = max - min,\n          newVal = value - min;\n      return 100 * newVal / newMax; // var absMin = Math.abs(min);\n      // return 100 * (absMin + value) / (max + absMin);\n    }\n    /**\n     * Gets cartesian co-ordinates for a specified radius and angle (in degrees)\n     * @param cx {Number} The center x co-oriinate\n     * @param cy {Number} The center y co-ordinate\n     * @param radius {Number} The radius of the circle\n     * @param angle {Number} The angle in degrees\n     * @return An object with x,y co-ordinates\n     */\n\n\n    function getCartesian(cx, cy, radius, angle) {\n      var rad = angle * Math.PI / 180;\n      return {\n        x: Math.round((cx + radius * Math.cos(rad)) * 1000) / 1000,\n        y: Math.round((cy + radius * Math.sin(rad)) * 1000) / 1000\n      };\n    } // Returns start and end points for dial\n    // i.e. starts at 135deg ends at 45deg with large arc flag\n    // REMEMBER!! angle=0 starts on X axis and then increases clockwise\n\n\n    function getDialCoords(radius, startAngle, endAngle) {\n      var cx = GaugeDefaults.centerX,\n          cy = GaugeDefaults.centerY;\n      return {\n        end: getCartesian(cx, cy, radius, endAngle),\n        start: getCartesian(cx, cy, radius, startAngle)\n      };\n    }\n    /**\n     * Creates a Gauge object. This should be called without the 'new' operator. Various options\n     * can be passed for the gauge:\n     * {\n     *    dialStartAngle: The angle to start the dial. MUST be greater than dialEndAngle. Default 135deg\n     *    dialEndAngle: The angle to end the dial. Default 45deg\n     *    radius: The gauge's radius. Default 400\n     *    max: The maximum value of the gauge. Default 100\n     *    value: The starting value of the gauge. Default 0\n     *    label: The function on how to render the center label (Should return a value)\n     * }\n     * @param {Element} elem The DOM into which to render the gauge\n     * @param {Object} opts The gauge options\n     * @return a Gauge object\n     */\n\n\n    return function Gauge(elem, opts) {\n      opts = shallowCopy({}, defaultOptions, opts);\n      var gaugeContainer = elem,\n          limit = opts.max,\n          min = opts.min,\n          value = normalize(opts.value, min, limit),\n          radius = opts.dialRadius,\n          displayValue = opts.showValue,\n          startAngle = opts.dialStartAngle,\n          endAngle = opts.dialEndAngle,\n          valueDialClass = opts.valueDialClass,\n          valueTextClass = opts.valueClass,\n          valueLabelClass = opts.valueLabelClass,\n          dialClass = opts.dialClass,\n          gaugeClass = opts.gaugeClass,\n          gaugeColor = opts.color,\n          gaugeValueElem,\n          gaugeValuePath,\n          label = opts.label,\n          viewBox = opts.viewBox,\n          instance;\n\n      if (startAngle < endAngle) {\n        console.log(\"WARN! startAngle < endAngle, Swapping\");\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      function pathString(radius, startAngle, endAngle, largeArc) {\n        var coords = getDialCoords(radius, startAngle, endAngle),\n            start = coords.start,\n            end = coords.end,\n            largeArcFlag = typeof largeArc === \"undefined\" ? 1 : largeArc;\n        return [\"M\", start.x, start.y, \"A\", radius, radius, 0, largeArcFlag, 1, end.x, end.y].join(\" \");\n      }\n\n      function initializeGauge(elem) {\n        gaugeValueElem = svg(\"text\", {\n          x: 50,\n          y: 50,\n          fill: \"#999\",\n          \"class\": valueTextClass,\n          \"font-size\": \"100%\",\n          \"font-family\": \"sans-serif\",\n          \"font-weight\": \"normal\",\n          \"text-anchor\": \"middle\",\n          \"alignment-baseline\": \"middle\",\n          \"dominant-baseline\": \"central\"\n        });\n        gaugeValuePath = svg(\"path\", {\n          \"class\": valueDialClass,\n          fill: \"none\",\n          stroke: \"#666\",\n          \"stroke-width\": 2.5,\n          d: pathString(radius, startAngle, startAngle) // value of 0\n\n        });\n        var angle = getAngle(100, 360 - Math.abs(startAngle - endAngle));\n        var flag = angle <= 180 ? 0 : 1;\n        var gaugeElement = svg(\"svg\", {\n          \"viewBox\": viewBox || \"0 0 100 100\",\n          \"class\": gaugeClass\n        }, [svg(\"path\", {\n          \"class\": dialClass,\n          fill: \"none\",\n          stroke: \"#eee\",\n          \"stroke-width\": 2,\n          d: pathString(radius, startAngle, endAngle, flag)\n        }), gaugeValueElem, gaugeValuePath]);\n        elem.appendChild(gaugeElement);\n      }\n\n      function updateGauge(theValue, frame) {\n        var val = getValueInPercentage(theValue, min, limit),\n            // angle = getAngle(val, 360 - Math.abs(endAngle - startAngle)),\n        angle = getAngle(val, 360 - Math.abs(startAngle - endAngle)),\n            // this is because we are using arc greater than 180deg\n        flag = angle <= 180 ? 0 : 1;\n\n        if (displayValue) {\n          gaugeValueElem.textContent = label.call(opts, theValue);\n        }\n\n        gaugeValuePath.setAttribute(\"d\", pathString(radius, startAngle, angle + startAngle, flag));\n      }\n\n      function setGaugeColor(value, duration) {\n        var c = gaugeColor(value),\n            dur = duration * 1000,\n            pathTransition = \"stroke \" + dur + \"ms ease\"; // textTransition = \"fill \" + dur + \"ms ease\";\n\n        gaugeValuePath.style = [\"stroke: \" + c, \"-webkit-transition: \" + pathTransition, \"-moz-transition: \" + pathTransition, \"transition: \" + pathTransition].join(\";\");\n        /*\n        gaugeValueElem.style = [\n          \"fill: \" + c,\n          \"-webkit-transition: \" + textTransition,\n          \"-moz-transition: \" + textTransition,\n          \"transition: \" + textTransition,\n        ].join(\";\");\n        */\n      }\n\n      instance = {\n        setMaxValue: function (max) {\n          limit = max;\n        },\n        setValue: function (val) {\n          value = normalize(val, min, limit);\n\n          if (gaugeColor) {\n            setGaugeColor(value, 0);\n          }\n\n          updateGauge(value);\n        },\n        setValueAnimated: function (val, duration) {\n          var oldVal = value;\n          value = normalize(val, min, limit);\n\n          if (oldVal === value) {\n            return;\n          }\n\n          if (gaugeColor) {\n            setGaugeColor(value, duration);\n          }\n\n          Animation({\n            start: oldVal || 0,\n            end: value,\n            duration: duration || 1,\n            step: function (val, frame) {\n              updateGauge(val, frame);\n            }\n          });\n        },\n        getValue: function () {\n          return value;\n        }\n      };\n      initializeGauge(gaugeContainer);\n      instance.setValue(value);\n      return instance;\n    };\n  }();\n\n  return Gauge;\n});","map":null,"metadata":{},"sourceType":"script"}