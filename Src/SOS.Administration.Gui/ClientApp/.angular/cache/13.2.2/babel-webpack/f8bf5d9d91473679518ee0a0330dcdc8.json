{"ast":null,"code":"import { Injectable, ɵɵdefineInjectable, EventEmitter, Directive, ElementRef, Input, Output, NgModule } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { cloneDeep } from 'lodash-es';\nimport { pluginService, Chart as Chart$1 } from 'chart.js';\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/default-colors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst defaultColors = [[255, 99, 132], [54, 162, 235], [255, 206, 86], [231, 233, 237], [75, 192, 192], [151, 187, 205], [220, 220, 220], [247, 70, 74], [70, 191, 189], [253, 180, 92], [148, 159, 177], [77, 83, 96]];\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/get-colors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generate colors by chart type\n * @param {?} chartType\n * @param {?} index\n * @param {?} count\n * @return {?}\n */\n\nfunction getColors(chartType, index, count) {\n  if (chartType === 'pie' || chartType === 'doughnut') {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === 'polarArea') {\n    return formatPolarAreaColors(generateColors(count));\n  }\n\n  if (chartType === 'line' || chartType === 'radar') {\n    return formatLineColor(generateColor(index));\n  }\n\n  if (chartType === 'bar' || chartType === 'horizontalBar') {\n    return formatBarColor(generateColor(index));\n  }\n\n  if (chartType === 'bubble') {\n    return formatPieColors(generateColors(count));\n  }\n\n  if (chartType === 'scatter') {\n    return formatPieColors(generateColors(count));\n  }\n\n  throw new Error('getColors - Unsupported chart type: ' + chartType);\n}\n/**\n * @param {?} colour\n * @param {?} alpha\n * @return {?}\n */\n\n\nfunction rgba(colour, alpha) {\n  return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n/**\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\n\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * @param {?} colors\n * @return {?}\n */\n\n\nfunction formatLineColor(colors) {\n  return {\n    backgroundColor: rgba(colors, 0.4),\n    borderColor: rgba(colors, 1),\n    pointBackgroundColor: rgba(colors, 1),\n    pointBorderColor: '#fff',\n    pointHoverBackgroundColor: '#fff',\n    pointHoverBorderColor: rgba(colors, 0.8)\n  };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\n\n\nfunction formatBarColor(colors) {\n  return {\n    backgroundColor: rgba(colors, 0.6),\n    borderColor: rgba(colors, 1),\n    hoverBackgroundColor: rgba(colors, 0.8),\n    hoverBorderColor: rgba(colors, 1)\n  };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\n\n\nfunction formatPieColors(colors) {\n  return {\n    backgroundColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 0.6)),\n    borderColor: colors.map(\n    /**\n    * @return {?}\n    */\n    () => '#fff'),\n    pointBackgroundColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 1)),\n    pointBorderColor: colors.map(\n    /**\n    * @return {?}\n    */\n    () => '#fff'),\n    pointHoverBackgroundColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 1)),\n    pointHoverBorderColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 1))\n  };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\n\n\nfunction formatPolarAreaColors(colors) {\n  return {\n    backgroundColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 0.6)),\n    borderColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 1)),\n    hoverBackgroundColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 0.8)),\n    hoverBorderColor: colors.map(\n    /**\n    * @param {?} color\n    * @return {?}\n    */\n    color => rgba(color, 1))\n  };\n}\n/**\n * @return {?}\n */\n\n\nfunction getRandomColor() {\n  return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\n * Generate colors for line|bar charts\n * @param {?} index\n * @return {?}\n */\n\n\nfunction generateColor(index) {\n  return defaultColors[index] || getRandomColor();\n}\n/**\n * Generate colors for pie|doughnut charts\n * @param {?} count\n * @return {?}\n */\n\n\nfunction generateColors(count) {\n  /** @type {?} */\n  const colorsArr = new Array(count);\n\n  for (let i = 0; i < count; i++) {\n    colorsArr[i] = defaultColors[i] || getRandomColor();\n  }\n\n  return colorsArr;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/theme.service.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ThemeService = /*#__PURE__*/(() => {\n  class ThemeService {\n    constructor() {\n      this.pColorschemesOptions = {};\n      this.colorschemesOptions = new BehaviorSubject({});\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    setColorschemesOptions(options) {\n      this.pColorschemesOptions = options;\n      this.colorschemesOptions.next(options);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getColorschemesOptions() {\n      return this.pColorschemesOptions;\n    }\n\n  }\n\n  ThemeService.ɵfac = function ThemeService_Factory(t) {\n    return new (t || ThemeService)();\n  };\n  /** @nocollapse */\n\n\n  /** @nocollapse */\n  ThemeService.ɵprov = ɵɵdefineInjectable({\n    factory: function ThemeService_Factory() {\n      return new ThemeService();\n    },\n    token: ThemeService,\n    providedIn: \"root\"\n  });\n  return ThemeService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  ThemeService.prototype.pColorschemesOptions;\n  /** @type {?} */\n\n  ThemeService.prototype.colorschemesOptions;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/base-chart.directive.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction OldState() {}\n\nif (false) {\n  /** @type {?} */\n  OldState.prototype.dataExists;\n  /** @type {?} */\n\n  OldState.prototype.dataLength;\n  /** @type {?} */\n\n  OldState.prototype.datasetsExists;\n  /** @type {?} */\n\n  OldState.prototype.datasetsLength;\n  /** @type {?} */\n\n  OldState.prototype.datasetsDataObjects;\n  /** @type {?} */\n\n  OldState.prototype.datasetsDataLengths;\n  /** @type {?} */\n\n  OldState.prototype.colorsExists;\n  /** @type {?} */\n\n  OldState.prototype.colors;\n  /** @type {?} */\n\n  OldState.prototype.labelsExist;\n  /** @type {?} */\n\n  OldState.prototype.labels;\n  /** @type {?} */\n\n  OldState.prototype.legendExists;\n  /** @type {?} */\n\n  OldState.prototype.legend;\n}\n/** @enum {number} */\n\n\nconst UpdateType = {\n  Default: 0,\n  Update: 1,\n  Refresh: 2\n};\nUpdateType[UpdateType.Default] = 'Default';\nUpdateType[UpdateType.Update] = 'Update';\nUpdateType[UpdateType.Refresh] = 'Refresh';\nlet BaseChartDirective = /*#__PURE__*/(() => {\n  class BaseChartDirective {\n    /**\n     * @param {?} element\n     * @param {?} themeService\n     */\n    constructor(element, themeService) {\n      this.element = element;\n      this.themeService = themeService;\n      this.options = {};\n      this.chartClick = new EventEmitter();\n      this.chartHover = new EventEmitter();\n      this.old = {\n        dataExists: false,\n        dataLength: 0,\n        datasetsExists: false,\n        datasetsLength: 0,\n        datasetsDataObjects: [],\n        datasetsDataLengths: [],\n        colorsExists: false,\n        colors: [],\n        labelsExist: false,\n        labels: [],\n        legendExists: false,\n        legend: {}\n      };\n      this.subs = [];\n    }\n    /**\n     * Register a plugin.\n     * @param {?} plugin\n     * @return {?}\n     */\n\n\n    static registerPlugin(plugin) {\n      pluginService.register(plugin);\n    }\n    /**\n     * @param {?} plugin\n     * @return {?}\n     */\n\n\n    static unregisterPlugin(plugin) {\n      pluginService.unregister(plugin);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnInit() {\n      this.ctx = this.element.nativeElement.getContext('2d');\n      this.refresh();\n      this.subs.push(this.themeService.colorschemesOptions.subscribe(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => this.themeChanged(r)));\n    }\n    /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n\n\n    themeChanged(options) {\n      this.refresh();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngDoCheck() {\n      if (!this.chart) {\n        return;\n      }\n      /** @type {?} */\n\n\n      let updateRequired = UpdateType.Default;\n      /** @type {?} */\n\n      const wantUpdate =\n      /**\n      * @param {?} x\n      * @return {?}\n      */\n      x => {\n        updateRequired = x > updateRequired ? x : updateRequired;\n      };\n\n      if (!!this.data !== this.old.dataExists) {\n        this.propagateDataToDatasets(this.data);\n        this.old.dataExists = !!this.data;\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (this.data && this.data.length !== this.old.dataLength) {\n        this.old.dataLength = this.data && this.data.length || 0;\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (!!this.datasets !== this.old.datasetsExists) {\n        this.old.datasetsExists = !!this.datasets;\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\n        this.old.datasetsLength = this.datasets && this.datasets.length || 0;\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (this.datasets && this.datasets.filter(\n      /**\n      * @param {?} x\n      * @param {?} i\n      * @return {?}\n      */\n      (x, i) => x.data !== this.old.datasetsDataObjects[i]).length) {\n        this.old.datasetsDataObjects = this.datasets.map(\n        /**\n        * @param {?} x\n        * @return {?}\n        */\n        x => x.data);\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (this.datasets && this.datasets.filter(\n      /**\n      * @param {?} x\n      * @param {?} i\n      * @return {?}\n      */\n      (x, i) => x.data.length !== this.old.datasetsDataLengths[i]).length) {\n        this.old.datasetsDataLengths = this.datasets.map(\n        /**\n        * @param {?} x\n        * @return {?}\n        */\n        x => x.data.length);\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (!!this.colors !== this.old.colorsExists) {\n        this.old.colorsExists = !!this.colors;\n        this.updateColors();\n        wantUpdate(UpdateType.Update);\n      } // This smells of inefficiency, might need to revisit this\n\n\n      if (this.colors && this.colors.filter(\n      /**\n      * @param {?} x\n      * @param {?} i\n      * @return {?}\n      */\n      (x, i) => !this.colorsEqual(x, this.old.colors[i])).length) {\n        this.old.colors = this.colors.map(\n        /**\n        * @param {?} x\n        * @return {?}\n        */\n        x => this.copyColor(x));\n        this.updateColors();\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (!!this.labels !== this.old.labelsExist) {\n        this.old.labelsExist = !!this.labels;\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (this.labels && this.labels.filter(\n      /**\n      * @param {?} x\n      * @param {?} i\n      * @return {?}\n      */\n      (x, i) => !this.labelsEqual(x, this.old.labels[i])).length) {\n        this.old.labels = this.labels.map(\n        /**\n        * @param {?} x\n        * @return {?}\n        */\n        x => this.copyLabel(x));\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (!!this.options.legend !== this.old.legendExists) {\n        this.old.legendExists = !!this.options.legend;\n        wantUpdate(UpdateType.Refresh);\n      }\n\n      if (this.options.legend && this.options.legend.position !== this.old.legend.position) {\n        this.old.legend.position = this.options.legend.position;\n        wantUpdate(UpdateType.Refresh);\n      }\n\n      switch (\n      /** @type {?} */\n      updateRequired) {\n        case UpdateType.Default:\n          break;\n\n        case UpdateType.Update:\n          this.update();\n          break;\n\n        case UpdateType.Refresh:\n          this.refresh();\n          break;\n      }\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n\n    copyLabel(a) {\n      if (Array.isArray(a)) {\n        return [...a];\n      }\n\n      return a;\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n\n\n    labelsEqual(a, b) {\n      return Array.isArray(a) === Array.isArray(b) && (Array.isArray(a) || a === b) && (!Array.isArray(a) || a.length === b.length) && (!Array.isArray(a) || a.filter(\n      /**\n      * @param {?} x\n      * @param {?} i\n      * @return {?}\n      */\n      (x, i) => x !== b[i]).length === 0);\n    }\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n\n\n    copyColor(a) {\n      return {\n        backgroundColor: a.backgroundColor,\n        borderWidth: a.borderWidth,\n        borderColor: a.borderColor,\n        borderCapStyle: a.borderCapStyle,\n        borderDash: a.borderDash,\n        borderDashOffset: a.borderDashOffset,\n        borderJoinStyle: a.borderJoinStyle,\n        pointBorderColor: a.pointBorderColor,\n        pointBackgroundColor: a.pointBackgroundColor,\n        pointBorderWidth: a.pointBorderWidth,\n        pointRadius: a.pointRadius,\n        pointHoverRadius: a.pointHoverRadius,\n        pointHitRadius: a.pointHitRadius,\n        pointHoverBackgroundColor: a.pointHoverBackgroundColor,\n        pointHoverBorderColor: a.pointHoverBorderColor,\n        pointHoverBorderWidth: a.pointHoverBorderWidth,\n        pointStyle: a.pointStyle,\n        hoverBackgroundColor: a.hoverBackgroundColor,\n        hoverBorderColor: a.hoverBorderColor,\n        hoverBorderWidth: a.hoverBorderWidth\n      };\n    }\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n\n\n    colorsEqual(a, b) {\n      if (!a !== !b) {\n        return false;\n      }\n\n      return !a || a.backgroundColor === b.backgroundColor && a.borderWidth === b.borderWidth && a.borderColor === b.borderColor && a.borderCapStyle === b.borderCapStyle && a.borderDash === b.borderDash && a.borderDashOffset === b.borderDashOffset && a.borderJoinStyle === b.borderJoinStyle && a.pointBorderColor === b.pointBorderColor && a.pointBackgroundColor === b.pointBackgroundColor && a.pointBorderWidth === b.pointBorderWidth && a.pointRadius === b.pointRadius && a.pointHoverRadius === b.pointHoverRadius && a.pointHitRadius === b.pointHitRadius && a.pointHoverBackgroundColor === b.pointHoverBackgroundColor && a.pointHoverBorderColor === b.pointHoverBorderColor && a.pointHoverBorderWidth === b.pointHoverBorderWidth && a.pointStyle === b.pointStyle && a.hoverBackgroundColor === b.hoverBackgroundColor && a.hoverBorderColor === b.hoverBorderColor && a.hoverBorderWidth === b.hoverBorderWidth;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    updateColors() {\n      this.datasets.forEach(\n      /**\n      * @param {?} elm\n      * @param {?} index\n      * @return {?}\n      */\n      (elm, index) => {\n        if (this.colors && this.colors[index]) {\n          Object.assign(elm, this.colors[index]);\n        } else {\n          Object.assign(elm, getColors(this.chartType, index, elm.data.length), Object.assign({}, elm));\n        }\n      });\n    }\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n\n\n    ngOnChanges(changes) {\n      /** @type {?} */\n      let updateRequired = UpdateType.Default;\n      /** @type {?} */\n\n      const wantUpdate =\n      /**\n      * @param {?} x\n      * @return {?}\n      */\n      x => {\n        updateRequired = x > updateRequired ? x : updateRequired;\n      }; // Check if the changes are in the data or datasets or labels or legend\n\n\n      if (changes.hasOwnProperty('data') && changes.data.currentValue) {\n        this.propagateDataToDatasets(changes.data.currentValue);\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {\n        this.propagateDatasetsToData(changes.datasets.currentValue);\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (changes.hasOwnProperty('labels')) {\n        if (this.chart) {\n          this.chart.data.labels = changes.labels.currentValue;\n        }\n\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (changes.hasOwnProperty('legend')) {\n        if (this.chart) {\n          this.chart.config.options.legend.display = changes.legend.currentValue;\n          this.chart.generateLegend();\n        }\n\n        wantUpdate(UpdateType.Update);\n      }\n\n      if (changes.hasOwnProperty('options')) {\n        wantUpdate(UpdateType.Refresh);\n      }\n\n      switch (\n      /** @type {?} */\n      updateRequired) {\n        case UpdateType.Update:\n          this.update();\n          break;\n\n        case UpdateType.Refresh:\n        case UpdateType.Default:\n          this.refresh();\n          break;\n      }\n    }\n    /**\n     * @return {?}\n     */\n\n\n    ngOnDestroy() {\n      if (this.chart) {\n        this.chart.destroy();\n        this.chart = void 0;\n      }\n\n      this.subs.forEach(\n      /**\n      * @param {?} x\n      * @return {?}\n      */\n      x => x.unsubscribe());\n    }\n    /**\n     * @param {?=} duration\n     * @return {?}\n     */\n\n\n    update(duration) {\n      if (this.chart) {\n        return this.chart.update(duration);\n      }\n    }\n    /**\n     * @param {?} index\n     * @param {?} hidden\n     * @return {?}\n     */\n\n\n    hideDataset(index, hidden) {\n      this.chart.getDatasetMeta(index).hidden = hidden;\n      this.chart.update();\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n\n    isDatasetHidden(index) {\n      return this.chart.getDatasetMeta(index).hidden;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    toBase64Image() {\n      return this.chart.toBase64Image();\n    }\n    /**\n     * @return {?}\n     */\n\n\n    getChartConfiguration() {\n      /** @type {?} */\n      const datasets = this.getDatasets();\n      /** @type {?} */\n\n      const options = Object.assign({}, this.options);\n\n      if (this.legend === false) {\n        options.legend = {\n          display: false\n        };\n      } // hook for onHover and onClick events\n\n\n      options.hover = options.hover || {};\n\n      if (!options.hover.onHover) {\n        options.hover.onHover =\n        /**\n        * @param {?} event\n        * @param {?} active\n        * @return {?}\n        */\n        (event, active) => {\n          if (active && !active.length) {\n            return;\n          }\n\n          this.chartHover.emit({\n            event,\n            active\n          });\n        };\n      }\n\n      if (!options.onClick) {\n        options.onClick =\n        /**\n        * @param {?=} event\n        * @param {?=} active\n        * @return {?}\n        */\n        (event, active) => {\n          this.chartClick.emit({\n            event,\n            active\n          });\n        };\n      }\n      /** @type {?} */\n\n\n      const mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());\n      return {\n        type: this.chartType,\n        data: {\n          labels: this.labels || [],\n          datasets\n        },\n        plugins: this.plugins,\n        options: mergedOptions\n      };\n    }\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n\n\n    getChartBuilder(ctx\n    /*, data:any[], options:any*/\n    ) {\n      /** @type {?} */\n      const chartConfig = this.getChartConfiguration();\n      return new Chart$1(ctx, chartConfig);\n    }\n    /**\n     * @param {?} options\n     * @param {?} overrides\n     * @param {?=} level\n     * @return {?}\n     */\n\n\n    smartMerge(options, overrides, level = 0) {\n      if (level === 0) {\n        options = cloneDeep(options);\n      }\n      /** @type {?} */\n\n\n      const keysToUpdate = Object.keys(overrides);\n      keysToUpdate.forEach(\n      /**\n      * @param {?} key\n      * @return {?}\n      */\n      key => {\n        if (Array.isArray(overrides[key])) {\n          /** @type {?} */\n          const arrayElements = options[key];\n\n          if (arrayElements) {\n            arrayElements.forEach(\n            /**\n            * @param {?} r\n            * @return {?}\n            */\n            r => {\n              this.smartMerge(r, overrides[key][0], level + 1);\n            });\n          }\n        } else if (typeof overrides[key] === 'object') {\n          if (!(key in options)) {\n            options[key] = {};\n          }\n\n          this.smartMerge(options[key], overrides[key], level + 1);\n        } else {\n          options[key] = overrides[key];\n        }\n      });\n\n      if (level === 0) {\n        return options;\n      }\n    }\n    /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n\n\n    isMultiLineLabel(label) {\n      return Array.isArray(label);\n    }\n    /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n\n\n    joinLabel(label) {\n      if (!label) {\n        return null;\n      }\n\n      if (this.isMultiLineLabel(label)) {\n        return label.join(' ');\n      } else {\n        return label;\n      }\n    }\n    /**\n     * @private\n     * @param {?} datasets\n     * @return {?}\n     */\n\n\n    propagateDatasetsToData(datasets) {\n      this.data = this.datasets.map(\n      /**\n      * @param {?} r\n      * @return {?}\n      */\n      r => r.data);\n\n      if (this.chart) {\n        this.chart.data.datasets = datasets;\n      }\n\n      this.updateColors();\n    }\n    /**\n     * @private\n     * @param {?} newDataValues\n     * @return {?}\n     */\n\n\n    propagateDataToDatasets(newDataValues) {\n      if (this.isMultiDataSet(newDataValues)) {\n        if (this.datasets && newDataValues.length === this.datasets.length) {\n          this.datasets.forEach(\n          /**\n          * @param {?} dataset\n          * @param {?} i\n          * @return {?}\n          */\n          (dataset, i) => {\n            dataset.data = newDataValues[i];\n          });\n        } else {\n          this.datasets = newDataValues.map(\n          /**\n          * @param {?} data\n          * @param {?} index\n          * @return {?}\n          */\n          (data, index) => {\n            return {\n              data,\n              label: this.joinLabel(this.labels[index]) || `Label ${index}`\n            };\n          });\n\n          if (this.chart) {\n            this.chart.data.datasets = this.datasets;\n          }\n        }\n      } else {\n        if (!this.datasets) {\n          this.datasets = [{\n            data: newDataValues\n          }];\n\n          if (this.chart) {\n            this.chart.data.datasets = this.datasets;\n          }\n        } else {\n          if (!this.datasets[0]) {\n            this.datasets[0] = {};\n          }\n\n          this.datasets[0].data = newDataValues;\n          this.datasets.splice(1); // Remove all elements but the first\n        }\n      }\n\n      this.updateColors();\n    }\n    /**\n     * @private\n     * @param {?} data\n     * @return {?}\n     */\n\n\n    isMultiDataSet(data) {\n      return Array.isArray(data[0]);\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    getDatasets() {\n      if (!this.datasets && !this.data) {\n        throw new Error(`ng-charts configuration error, data or datasets field are required to render chart ${this.chartType}`);\n      } // If `datasets` is defined, use it over the `data` property.\n\n\n      if (this.datasets) {\n        this.propagateDatasetsToData(this.datasets);\n        return this.datasets;\n      }\n\n      if (this.data) {\n        this.propagateDataToDatasets(this.data);\n        return this.datasets;\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n\n    refresh() {\n      // if (this.options && this.options.responsive) {\n      //   setTimeout(() => this.refresh(), 50);\n      // }\n      // todo: remove this line, it is producing flickering\n      if (this.chart) {\n        this.chart.destroy();\n        this.chart = void 0;\n      }\n\n      if (this.ctx) {\n        this.chart = this.getChartBuilder(this.ctx\n        /*, data, this.options*/\n        );\n      }\n    }\n\n  }\n\n  BaseChartDirective.ɵfac = function BaseChartDirective_Factory(t) {\n    return new (t || BaseChartDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ThemeService));\n  };\n\n  BaseChartDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: BaseChartDirective,\n    selectors: [[\"canvas\", \"baseChart\", \"\"]],\n    inputs: {\n      options: \"options\",\n      data: \"data\",\n      datasets: \"datasets\",\n      labels: \"labels\",\n      chartType: \"chartType\",\n      colors: \"colors\",\n      legend: \"legend\",\n      plugins: \"plugins\"\n    },\n    outputs: {\n      chartClick: \"chartClick\",\n      chartHover: \"chartHover\"\n    },\n    exportAs: [\"base-chart\"],\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n  /** @nocollapse */\n\n  return BaseChartDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /** @type {?} */\n  BaseChartDirective.prototype.data;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.datasets;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.labels;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.options;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.chartType;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.colors;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.legend;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.plugins;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.chartClick;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.chartHover;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.ctx;\n  /** @type {?} */\n\n  BaseChartDirective.prototype.chart;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BaseChartDirective.prototype.old;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BaseChartDirective.prototype.subs;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BaseChartDirective.prototype.element;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  BaseChartDirective.prototype.themeService;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/charts.module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet ChartsModule = /*#__PURE__*/(() => {\n  class ChartsModule {}\n\n  ChartsModule.ɵfac = function ChartsModule_Factory(t) {\n    return new (t || ChartsModule)();\n  };\n\n  ChartsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: ChartsModule\n  });\n  ChartsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return ChartsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartsModule, {\n    declarations: [BaseChartDirective],\n    exports: [BaseChartDirective]\n  });\n})();\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/color.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction Color() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  Color.prototype.backgroundColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderWidth;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderCapStyle;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderDash;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderDashOffset;\n  /** @type {?|undefined} */\n\n  Color.prototype.borderJoinStyle;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointBorderColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointBackgroundColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointBorderWidth;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointRadius;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointHoverRadius;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointHitRadius;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointHoverBackgroundColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointHoverBorderColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointHoverBorderWidth;\n  /** @type {?|undefined} */\n\n  Color.prototype.pointStyle;\n  /** @type {?|undefined} */\n\n  Color.prototype.hoverBackgroundColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.hoverBorderColor;\n  /** @type {?|undefined} */\n\n  Color.prototype.hoverBorderWidth;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/colors.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\n\nfunction Colors() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  Colors.prototype.data;\n  /** @type {?|undefined} */\n\n  Colors.prototype.label;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/monkey-patch-chart-js-legend.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n\n/**\n * @return {?}\n */\n\n\nfunction monkeyPatchChartJsLegend() {\n  if (typeof Chart === 'undefined') {\n    console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n    return;\n  }\n  /** @type {?} */\n\n\n  const plugins = Chart.plugins.getAll();\n  /** @type {?} */\n\n  const legend = plugins.filter(\n  /**\n  * @param {?} p\n  * @return {?}\n  */\n  p => p.id === 'legend')[0];\n  legend._element.prototype.fit = fit;\n  legend._element.prototype.draw = draw;\n  /** @type {?} */\n\n  const helpers = Chart.helpers;\n  /** @type {?} */\n\n  const defaults = Chart.defaults;\n  /** @type {?} */\n\n  const valueOrDefault = helpers.valueOrDefault;\n  /**\n   * @param {?} labelOpts\n   * @param {?} fontSize\n   * @return {?}\n   */\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  function fit() {\n    /** @type {?} */\n    var me = this;\n    /** @type {?} */\n\n    var opts = me.options;\n    /** @type {?} */\n\n    var labelOpts = opts.labels;\n    /** @type {?} */\n\n    var display = opts.display;\n    /** @type {?} */\n\n    var ctx = me.ctx;\n    /** @type {?} */\n\n    var labelFont = helpers.options._parseFont(labelOpts);\n    /** @type {?} */\n\n\n    var fontSize = labelFont.size; // Reset hit boxes\n\n    /** @type {?} */\n\n    var hitboxes = me.legendHitBoxes = [];\n    /** @type {?} */\n\n    var minSize = me.minSize;\n    /** @type {?} */\n\n    var isHorizontal = me.isHorizontal();\n\n    if (isHorizontal) {\n      minSize.width = me.maxWidth; // fill all the width\n\n      minSize.height = display ? 10 : 0;\n    } else {\n      minSize.width = display ? 10 : 0;\n      minSize.height = me.maxHeight; // fill all the height\n    }\n    /** @type {?} */\n\n\n    var getMaxLineWidth =\n    /**\n    * @param {?} textLines\n    * @return {?}\n    */\n    function (textLines) {\n      return textLines.map(\n      /**\n      * @param {?} textLine\n      * @return {?}\n      */\n      function (textLine) {\n        return ctx.measureText(textLine).width;\n      }).reduce(\n      /**\n      * @param {?} acc\n      * @param {?} v\n      * @return {?}\n      */\n      function (acc, v) {\n        return v > acc ? v : acc;\n      }, 0);\n    }; // Increase sizes here\n\n\n    if (display) {\n      ctx.font = labelFont.string;\n\n      if (isHorizontal) {\n        // Labels\n        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\n        /** @type {?} */\n        var lineWidths = me.lineWidths = [0];\n        /** @type {?} */\n\n        var lineHeights = me.lineHeights = [];\n        /** @type {?} */\n\n        var currentLineHeight = 0;\n        /** @type {?} */\n\n        var lineIndex = 0;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n        helpers.each(me.legendItems,\n        /**\n        * @param {?} legendItem\n        * @param {?} i\n        * @return {?}\n        */\n        function (legendItem, i) {\n          /** @type {?} */\n          var width;\n          /** @type {?} */\n\n          var height;\n\n          if (helpers.isArray(legendItem.text)) {\n            width = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length + labelOpts.padding;\n          } else {\n            width = ctx.measureText(legendItem.text).width;\n            height = fontSize + labelOpts.padding;\n          }\n\n          width += getBoxWidth(labelOpts, fontSize) + fontSize / 2;\n\n          if (lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n            lineHeights.push(currentLineHeight);\n            currentLineHeight = 0;\n            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n            lineIndex++;\n          }\n\n          legendItem.lineOrColumnIndex = lineIndex;\n\n          if (height > currentLineHeight) {\n            currentLineHeight = height;\n          } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: width,\n            height: height\n          };\n          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n        });\n        lineHeights.push(currentLineHeight);\n        minSize.height += lineHeights.reduce(\n        /**\n        * @param {?} acc\n        * @param {?} v\n        * @return {?}\n        */\n        function (acc, v) {\n          return acc + v;\n        }, 0);\n      } else {\n        /** @type {?} */\n        var vPadding = labelOpts.padding;\n        /** @type {?} */\n\n        var columnWidths = me.columnWidths = [];\n        /** @type {?} */\n\n        var columnHeights = me.columnHeights = [];\n        /** @type {?} */\n\n        var totalWidth = labelOpts.padding;\n        /** @type {?} */\n\n        var currentColWidth = 0;\n        /** @type {?} */\n\n        var currentColHeight = 0;\n        /** @type {?} */\n\n        var columnIndex = 0;\n        helpers.each(me.legendItems,\n        /**\n        * @param {?} legendItem\n        * @param {?} i\n        * @return {?}\n        */\n        function (legendItem, i) {\n          /** @type {?} */\n          var itemWidth;\n          /** @type {?} */\n\n          var height;\n\n          if (helpers.isArray(legendItem.text)) {\n            itemWidth = getMaxLineWidth(legendItem.text);\n            height = fontSize * legendItem.text.length;\n          } else {\n            itemWidth = ctx.measureText(legendItem.text).width;\n            height = fontSize;\n          }\n\n          itemWidth += getBoxWidth(labelOpts, fontSize) + fontSize / 2; // If too tall, go to new column\n\n          if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n            totalWidth += currentColWidth + labelOpts.padding;\n            columnWidths.push(currentColWidth); // previous column width\n\n            columnHeights.push(currentColHeight);\n            currentColWidth = 0;\n            currentColHeight = 0;\n            columnIndex++;\n          }\n\n          legendItem.lineOrColumnIndex = columnIndex; // Get max width\n\n          currentColWidth = Math.max(currentColWidth, itemWidth);\n          currentColHeight += height + vPadding; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n          hitboxes[i] = {\n            left: 0,\n            top: 0,\n            width: itemWidth,\n            height: height\n          };\n        });\n        totalWidth += currentColWidth;\n        columnWidths.push(currentColWidth);\n        columnHeights.push(currentColHeight);\n        minSize.width += totalWidth;\n      }\n    }\n\n    me.width = minSize.width;\n    me.height = minSize.height;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  function draw() {\n    /** @type {?} */\n    var me = this;\n    /** @type {?} */\n\n    var opts = me.options;\n    /** @type {?} */\n\n    var labelOpts = opts.labels;\n    /** @type {?} */\n\n    var globalDefaults = defaults.global;\n    /** @type {?} */\n\n    var defaultColor = globalDefaults.defaultColor;\n    /** @type {?} */\n\n    var lineDefault = globalDefaults.elements.line;\n    /** @type {?} */\n\n    var legendHeight = me.height;\n    /** @type {?} */\n\n    var columnHeights = me.columnHeights;\n    /** @type {?} */\n\n    var columnWidths = me.columnWidths;\n    /** @type {?} */\n\n    var legendWidth = me.width;\n    /** @type {?} */\n\n    var lineWidths = me.lineWidths;\n    /** @type {?} */\n\n    var lineHeights = me.lineHeights;\n\n    if (opts.display) {\n      /** @type {?} */\n      var ctx = me.ctx;\n      /** @type {?} */\n\n      var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\n      /** @type {?} */\n\n      var labelFont = helpers.options._parseFont(labelOpts);\n      /** @type {?} */\n\n\n      var fontSize = labelFont.size;\n      /** @type {?} */\n\n      var cursor; // Canvas setup\n\n      ctx.textAlign = 'left';\n      ctx.textBaseline = 'middle';\n      ctx.lineWidth = 0.5;\n      ctx.strokeStyle = fontColor; // for strikethrough effect\n\n      ctx.fillStyle = fontColor; // render in correct colour\n\n      ctx.font = labelFont.string;\n      /** @type {?} */\n\n      var boxWidth = getBoxWidth(labelOpts, fontSize);\n      /** @type {?} */\n\n      var hitboxes = me.legendHitBoxes; // current position\n\n      /** @type {?} */\n\n      var drawLegendBox =\n      /**\n      * @param {?} x\n      * @param {?} y\n      * @param {?} legendItem\n      * @return {?}\n      */\n      function (x, y, legendItem) {\n        if (isNaN(boxWidth) || boxWidth <= 0) {\n          return;\n        } // Set the ctx for the box\n\n\n        ctx.save();\n        /** @type {?} */\n\n        var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n        ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n        if (ctx.setLineDash) {\n          // IE 9 and 10 do not support line dash\n          ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n        }\n\n        if (opts.labels && opts.labels.usePointStyle) {\n          // Recalculate x and y for drawPoint() because its expecting\n          // x and y to be center of figure (instead of top left)\n\n          /** @type {?} */\n          var radius = boxWidth * Math.SQRT2 / 2;\n          /** @type {?} */\n\n          var centerX = x + boxWidth / 2;\n          /** @type {?} */\n\n          var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol\n\n          helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n        } else {\n          // Draw box as legend symbol\n          if (lineWidth !== 0) {\n            ctx.strokeRect(x, y, boxWidth, fontSize);\n          }\n\n          ctx.fillRect(x, y, boxWidth, fontSize);\n        }\n\n        ctx.restore();\n      };\n      /** @type {?} */\n\n\n      var drawStrikeThrough =\n      /**\n      * @param {?} x\n      * @param {?} y\n      * @param {?} w\n      * @return {?}\n      */\n      function (x, y, w) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n      /** @type {?} */\n\n\n      var drawCrossOver =\n      /**\n      * @param {?} x\n      * @param {?} y\n      * @param {?} w\n      * @param {?} h\n      * @return {?}\n      */\n      function (x, y, w, h) {\n        ctx.beginPath();\n        ctx.lineWidth = 2;\n        ctx.moveTo(x, y);\n        ctx.lineTo(x + w, y + h);\n        ctx.moveTo(x, y + h);\n        ctx.lineTo(x + w, y);\n        ctx.stroke();\n      };\n      /** @type {?} */\n\n\n      var fillText =\n      /**\n      * @param {?} x\n      * @param {?} y\n      * @param {?} legendItem\n      * @param {?} textWidth\n      * @return {?}\n      */\n      function (x, y, legendItem, textWidth) {\n        /** @type {?} */\n        var halfFontSize = fontSize / 2;\n        /** @type {?} */\n\n        var xLeft = boxWidth + halfFontSize + x;\n        /** @type {?} */\n\n        var yMiddle = y + halfFontSize;\n\n        if (helpers.isArray(legendItem.text)) {\n          helpers.each(legendItem.text,\n          /**\n          * @param {?} textLine\n          * @param {?} index\n          * @return {?}\n          */\n          function (textLine, index) {\n            /** @type {?} */\n            var lineOffset = index * fontSize;\n            ctx.fillText(textLine, xLeft, yMiddle + lineOffset);\n          });\n        } else {\n          ctx.fillText(legendItem.text, xLeft, yMiddle);\n        }\n\n        if (legendItem.hidden) {\n          if (helpers.isArray(legendItem.text)) {\n            drawCrossOver(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize - 1));\n          } else {\n            drawStrikeThrough(xLeft, yMiddle, textWidth);\n          }\n        }\n      };\n      /** @type {?} */\n\n\n      var alignmentOffset =\n      /**\n      * @param {?} dimension\n      * @param {?} blockSize\n      * @return {?}\n      */\n      function (dimension, blockSize) {\n        switch (opts.align) {\n          case 'start':\n            return labelOpts.padding;\n\n          case 'end':\n            return dimension - blockSize;\n\n          default:\n            // center\n            return (dimension - blockSize + labelOpts.padding) / 2;\n        }\n      }; // Horizontal\n\n      /** @type {?} */\n\n\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        cursor = {\n          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n          y: me.top + labelOpts.padding,\n          line: 0\n        };\n      } else {\n        cursor = {\n          x: me.left + labelOpts.padding,\n          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n          line: 0\n        };\n      }\n\n      helpers.each(me.legendItems,\n      /**\n      * @param {?} legendItem\n      * @param {?} i\n      * @return {?}\n      */\n      function (legendItem, i) {\n        /** @type {?} */\n        var textWidth;\n        /** @type {?} */\n\n        var height;\n        /** @type {?} */\n\n        var boxTopOffset;\n\n        if (legendItem.lineOrColumnIndex > cursor.line) {\n          if (isHorizontal) {\n            cursor.y += lineHeights[cursor.line];\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n          } else {\n            cursor.x += columnWidths[cursor.line] + labelOpts.padding;\n            cursor.line = legendItem.lineOrColumnIndex;\n            cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n          }\n        }\n\n        if (helpers.isArray(legendItem.text)) {\n          textWidth = legendItem.text.map(\n          /**\n          * @param {?} textLine\n          * @return {?}\n          */\n          function (textLine) {\n            return ctx.measureText(textLine).width;\n          }).reduce(\n          /**\n          * @param {?} acc\n          * @param {?} v\n          * @return {?}\n          */\n          function (acc, v) {\n            return v > acc ? v : acc;\n          }, 0);\n          boxTopOffset = fontSize / 2 * (legendItem.text.length - 1);\n          height = fontSize * legendItem.text.length;\n        } else {\n          textWidth = ctx.measureText(legendItem.text).width;\n          boxTopOffset = 0;\n          height = fontSize;\n        }\n        /** @type {?} */\n\n\n        var width = boxWidth + fontSize / 2 + textWidth;\n        /** @type {?} */\n\n        var x = cursor.x;\n        /** @type {?} */\n\n        var y = cursor.y;\n        /** @type {?} */\n\n        var topOffset = isHorizontal ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2) : 0;\n        drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);\n        hitboxes[i].left = x;\n        hitboxes[i].top = y; // Fill the actual label\n\n        fillText(x, y + topOffset, legendItem, textWidth);\n\n        if (isHorizontal) {\n          cursor.x += width + labelOpts.padding;\n        } else {\n          cursor.y += height + labelOpts.padding;\n        }\n      });\n    }\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: lib/monkey-patch-chart-js-tooltip.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n\n/**\n * @return {?}\n */\n\n\nfunction monkeyPatchChartJsTooltip() {\n  if (typeof Chart === 'undefined') {\n    console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n    return;\n  }\n\n  Chart.Tooltip.prototype.drawBody = drawBody;\n  /** @type {?} */\n\n  const helpers = Chart.helpers;\n  /**\n   * @param {?} vm\n   * @param {?} align\n   * @return {?}\n   */\n\n  function getAlignedX(vm, align) {\n    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;\n  }\n  /**\n   * @param {?} pt\n   * @param {?} vm\n   * @param {?} ctx\n   * @return {?}\n   */\n\n\n  function drawBody(pt, vm, ctx) {\n    /** @type {?} */\n    var bodyFontSize = vm.bodyFontSize;\n    /** @type {?} */\n\n    var bodySpacing = vm.bodySpacing;\n    /** @type {?} */\n\n    var bodyAlign = vm._bodyAlign;\n    /** @type {?} */\n\n    var body = vm.body;\n    /** @type {?} */\n\n    var drawColorBoxes = vm.displayColors;\n    /** @type {?} */\n\n    var labelColors = vm.labelColors;\n    /** @type {?} */\n\n    var xLinePadding = 0;\n    /** @type {?} */\n\n    var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n    /** @type {?} */\n\n    var textColor;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'top';\n    ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n    pt.x = getAlignedX(vm, bodyAlign); // Before Body\n\n    /** @type {?} */\n\n    var fillLineOfText =\n    /**\n    * @param {?} line\n    * @return {?}\n    */\n    function (line) {\n      ctx.fillText(line, pt.x + xLinePadding, pt.y);\n      pt.y += bodyFontSize + bodySpacing;\n    }; // Before body lines\n\n\n    ctx.fillStyle = vm.bodyFontColor;\n    helpers.each(vm.beforeBody, fillLineOfText);\n    xLinePadding = drawColorBoxes && bodyAlign !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now\n\n    helpers.each(body,\n    /**\n    * @param {?} bodyItem\n    * @param {?} i\n    * @return {?}\n    */\n    function (bodyItem, i) {\n      textColor = vm.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      helpers.each(bodyItem.before, fillLineOfText); // Draw Legend-like boxes if needed\n\n      if (drawColorBoxes) {\n        // Fill a white rect so that colours merge nicely if the opacity is < 1\n        ctx.fillStyle = vm.legendColorBackground;\n        ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Border\n\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = labelColors[i].borderColor;\n        ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize); // Inner square\n\n        ctx.fillStyle = labelColors[i].backgroundColor;\n        ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n        ctx.fillStyle = textColor;\n      }\n\n      helpers.each(bodyItem.lines, fillLineOfText);\n      helpers.each(bodyItem.after, fillLineOfText);\n    }); // Reset back to 0 for after body\n\n    xLinePadding = 0; // After body lines\n\n    helpers.each(vm.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ng2-charts.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { BaseChartDirective, ChartsModule, ThemeService, defaultColors, monkeyPatchChartJsLegend, monkeyPatchChartJsTooltip }; //# sourceMappingURL=ng2-charts.js.map","map":null,"metadata":{},"sourceType":"module"}