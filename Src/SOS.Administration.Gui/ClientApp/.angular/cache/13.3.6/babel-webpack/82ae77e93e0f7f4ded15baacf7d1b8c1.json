{"ast":null,"code":"import { Directive, Input, IterableDiffers, NgZone } from '@angular/core';\nimport { LeafletDirective } from '../core/leaflet.directive';\nimport { LeafletDirectiveWrapper } from '../core/leaflet.directive.wrapper';\n/**\n * Layers directive\n *\n * This directive is used to directly control map layers. As changes are made to the input array of\n * layers, the map is synched to the array. As layers are added or removed from the input array, they\n * are also added or removed from the map. The input array is treated as immutable. To detect changes,\n * you must change the array instance.\n *\n * Important Note: The input layers array is assumed to be immutable. This means you need to use an\n * immutable array implementation or create a new copy of your array when you make changes, otherwise\n * this directive won't detect the change. This is by design. It's for performance reasons. Change\n * detection of mutable arrays requires diffing the state of the array on every DoCheck cycle, which\n * is extremely expensive from a time complexity perspective.\n *\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '../core/leaflet.directive';\n\nvar LeafletLayersDirective =\n/** @class */\nfunction () {\n  function LeafletLayersDirective(leafletDirective, differs, zone) {\n    this.differs = differs;\n    this.zone = zone;\n    this.leafletDirective = new LeafletDirectiveWrapper(leafletDirective);\n    this.layersDiffer = this.differs.find([]).create();\n  }\n\n  Object.defineProperty(LeafletLayersDirective.prototype, \"layers\", {\n    get: function () {\n      return this.layersValue;\n    },\n    // Set/get the layers\n    set: function (v) {\n      this.layersValue = v; // Now that we have a differ, do an immediate layer update\n\n      this.updateLayers();\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  LeafletLayersDirective.prototype.ngDoCheck = function () {\n    this.updateLayers();\n  };\n\n  LeafletLayersDirective.prototype.ngOnInit = function () {\n    // Init the map\n    this.leafletDirective.init(); // Update layers once the map is ready\n\n    this.updateLayers();\n  };\n\n  LeafletLayersDirective.prototype.ngOnDestroy = function () {\n    this.layers = [];\n  };\n  /**\n   * Update the state of the layers.\n   * We use an iterable differ to synchronize the map layers with the state of the bound layers array.\n   * This is important because it allows us to react to changes to the contents of the array as well\n   * as changes to the actual array instance.\n   */\n\n\n  LeafletLayersDirective.prototype.updateLayers = function () {\n    var map = this.leafletDirective.getMap();\n\n    if (null != map && null != this.layersDiffer) {\n      var changes_1 = this.layersDiffer.diff(this.layersValue);\n\n      if (null != changes_1) {\n        // Run outside angular to ensure layer events don't trigger change detection\n        this.zone.runOutsideAngular(function () {\n          changes_1.forEachRemovedItem(function (c) {\n            map.removeLayer(c.item);\n          });\n          changes_1.forEachAddedItem(function (c) {\n            map.addLayer(c.item);\n          });\n        });\n      }\n    }\n  };\n\n  LeafletLayersDirective.ctorParameters = function () {\n    return [{\n      type: LeafletDirective\n    }, {\n      type: IterableDiffers\n    }, {\n      type: NgZone\n    }];\n  };\n\n  LeafletLayersDirective.propDecorators = {\n    layers: [{\n      type: Input,\n      args: ['leafletLayers']\n    }]\n  };\n\n  LeafletLayersDirective.ɵfac = function LeafletLayersDirective_Factory(t) {\n    return new (t || LeafletLayersDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.LeafletDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  LeafletLayersDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: LeafletLayersDirective,\n    selectors: [[\"\", \"leafletLayers\", \"\"]],\n    inputs: {\n      layers: [\"leafletLayers\", \"layers\"]\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return LeafletLayersDirective;\n}();\n\nexport { LeafletLayersDirective }; //# sourceMappingURL=leaflet-layers.directive.js.map","map":null,"metadata":{},"sourceType":"module"}