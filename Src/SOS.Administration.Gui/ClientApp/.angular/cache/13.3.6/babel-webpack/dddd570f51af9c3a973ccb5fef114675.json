{"ast":null,"code":"import { InjectionToken, Injectable, Inject, NgModule, Optional, SkipSelf } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { mergeMap } from 'rxjs/operators';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport * as ɵngcc0 from '@angular/core';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS'); // tslint:disable:no-bitwise\n\nlet JwtHelperService = /*#__PURE__*/(() => {\n  class JwtHelperService {\n    constructor(config = null) {\n      this.tokenGetter = config && config.tokenGetter || function () {};\n    }\n\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n\n        case 2:\n          {\n            output += \"==\";\n            break;\n          }\n\n        case 3:\n          {\n            output += \"=\";\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Illegal base64url string!\");\n          }\n      }\n\n      return this.b64DecodeUnicode(output);\n    } // credits for decoder goes to https://github.com/atk\n\n\n    b64decode(str) {\n      const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      let output = \"\";\n      str = String(str).replace(/=+$/, \"\");\n\n      if (str.length % 4 === 1) {\n        throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n      }\n\n      for ( // initialize result and counters\n      let bc = 0, bs, buffer, idx = 0; // get next character\n      buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n\n      return output;\n    }\n\n    b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\"));\n    }\n\n    decodeToken(token = this.tokenGetter()) {\n      if (!token || token === \"\") {\n        return null;\n      }\n\n      const parts = token.split(\".\");\n\n      if (parts.length !== 3) {\n        throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n      }\n\n      const decoded = this.urlBase64Decode(parts[1]);\n\n      if (!decoded) {\n        throw new Error(\"Cannot decode the token.\");\n      }\n\n      return JSON.parse(decoded);\n    }\n\n    getTokenExpirationDate(token = this.tokenGetter()) {\n      let decoded;\n      decoded = this.decodeToken(token);\n\n      if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n        return null;\n      }\n\n      const date = new Date(0);\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n      if (!token || token === \"\") {\n        return true;\n      }\n\n      const date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n\n      if (date === null) {\n        return false;\n      }\n\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n\n    getAuthScheme(authScheme, request) {\n      if (typeof authScheme === \"function\") {\n        return authScheme(request);\n      }\n\n      return authScheme;\n    }\n\n  }\n\n  JwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n    return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS));\n  };\n\n  JwtHelperService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: JwtHelperService,\n    factory: JwtHelperService.ɵfac\n  });\n  return JwtHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet JwtInterceptor = /*#__PURE__*/(() => {\n  class JwtInterceptor {\n    constructor(config, jwtHelper, document) {\n      this.jwtHelper = jwtHelper;\n      this.document = document;\n      this.standardPorts = [\"80\", \"443\"];\n      this.tokenGetter = config.tokenGetter;\n      this.headerName = config.headerName || \"Authorization\";\n      this.authScheme = config.authScheme || config.authScheme === \"\" ? config.authScheme : \"Bearer \";\n      this.allowedDomains = config.allowedDomains || [];\n      this.disallowedRoutes = config.disallowedRoutes || [];\n      this.throwNoTokenError = config.throwNoTokenError || false;\n      this.skipWhenExpired = config.skipWhenExpired;\n    }\n\n    isAllowedDomain(request) {\n      const requestUrl = new URL(request.url, this.document.location.origin); // If the host equals the current window origin,\n      // the domain is allowed by default\n\n      if (requestUrl.host === this.document.location.host) {\n        return true;\n      } // If not the current domain, check the allowed list\n\n\n      const hostName = `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? \":\" + requestUrl.port : \"\"}`;\n      return this.allowedDomains.findIndex(domain => typeof domain === \"string\" ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n    }\n\n    isDisallowedRoute(request) {\n      const requestedUrl = new URL(request.url, this.document.location.origin);\n      return this.disallowedRoutes.findIndex(route => {\n        if (typeof route === \"string\") {\n          const parsedRoute = new URL(route, this.document.location.origin);\n          return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.pathname === requestedUrl.pathname;\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1;\n    }\n\n    handleInterception(token, request, next) {\n      const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n      let tokenIsExpired = false;\n\n      if (!token && this.throwNoTokenError) {\n        throw new Error(\"Could not get token from tokenGetter function.\");\n      }\n\n      if (this.skipWhenExpired) {\n        tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n      }\n\n      if (token && tokenIsExpired && this.skipWhenExpired) {\n        request = request.clone();\n      } else if (token) {\n        request = request.clone({\n          setHeaders: {\n            [this.headerName]: `${authScheme}${token}`\n          }\n        });\n      }\n\n      return next.handle(request);\n    }\n\n    intercept(request, next) {\n      if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n        return next.handle(request);\n      }\n\n      const token = this.tokenGetter(request);\n\n      if (token instanceof Promise) {\n        return from(token).pipe(mergeMap(asyncToken => {\n          return this.handleInterception(asyncToken, request, next);\n        }));\n      } else {\n        return this.handleInterception(token, request, next);\n      }\n    }\n\n  }\n\n  JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n    return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  JwtInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: JwtInterceptor,\n    factory: JwtInterceptor.ɵfac\n  });\n  return JwtInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet JwtModule = /*#__PURE__*/(() => {\n  class JwtModule {\n    constructor(parentModule) {\n      if (parentModule) {\n        throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n      }\n    }\n\n    static forRoot(options) {\n      return {\n        ngModule: JwtModule,\n        providers: [{\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true\n        }, options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config\n        }, JwtHelperService]\n      };\n    }\n\n  }\n\n  JwtModule.ɵfac = function JwtModule_Factory(t) {\n    return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12));\n  };\n\n  JwtModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: JwtModule\n  });\n  JwtModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return JwtModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule }; //# sourceMappingURL=auth0-angular-jwt.js.map","map":null,"metadata":{},"sourceType":"module"}