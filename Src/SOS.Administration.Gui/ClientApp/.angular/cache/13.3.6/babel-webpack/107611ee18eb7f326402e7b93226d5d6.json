{"ast":null,"code":"import { EventEmitter, Component, ElementRef, Input, Output, InjectionToken, NgModule } from '@angular/core';\nimport Gauge from 'svg-gauge';\nimport * as ɵngcc0 from '@angular/core';\n\nclass GaugeDefaults {\n  constructor() {\n    /**\n     * The angle in degrees to start the dial\n     */\n    this.dialStartAngle = 135;\n    /**\n     * The angle in degrees to end the dial. This MUST be less than dialStartAngle\n     */\n\n    this.dialEndAngle = 45;\n    /**\n     * The radius of the gauge\n     */\n\n    this.dialRadius = 40;\n    /**\n     * The minimum value for the gauge\n     */\n\n    this.min = 0;\n    /**\n     * The maximum value for the gauge\n     */\n\n    this.max = 100;\n    /**\n     * Whether to show the value at the center of the gauge\n     */\n\n    this.showValue = true;\n    /**\n     * The CSS class of the gauge\n     */\n\n    this.gaugeClass = 'gauge';\n    /**\n     * The CSS class of the gauge's dial\n     */\n\n    this.dialClass = 'dial';\n    /**\n     * The CSS class of the gauge's fill (value dial)\n     */\n\n    this.valueDialClass = 'value';\n    /**\n     * \tThe CSS class of the gauge's text\n     */\n\n    this.valueClass = 'value-text';\n    /**\n     * Whether to animate changing the gauge\n     */\n\n    this.animated = false;\n  }\n\n}\n\nlet GaugeComponent = /*#__PURE__*/(() => {\n  class GaugeComponent {\n    constructor(elm, defaults) {\n      this.elm = elm;\n      this.defaults = defaults;\n      /**\n       * Called when the gauge is created\n       */\n\n      this.gaugeCreated = new EventEmitter();\n    }\n\n    ngAfterViewInit() {\n      const options = {\n        dialStartAngle: this.dialStartAngle,\n        dialEndAngle: this.dialEndAngle,\n        dialRadius: this.dialRadius,\n        min: this.min,\n        max: this.max,\n        label: this.label,\n        showValue: this.showValue,\n        gaugeClass: this.gaugeClass,\n        dialClass: this.dialClass,\n        valueDialClass: this.valueDialClass,\n        valueClass: this.valueClass,\n        value: this.value,\n        color: this.color\n      };\n      Object.keys(this.defaults).forEach(optionKey => {\n        if (typeof options[optionKey] === 'undefined') {\n          options[optionKey] = this.defaults[optionKey];\n        }\n      });\n      Object.keys(options).forEach(optionKey => {\n        if (typeof options[optionKey] === 'undefined') {\n          delete options[optionKey];\n        }\n      });\n      this.gauge = Gauge(this.elm.nativeElement, options);\n      this.gaugeCreated.emit({\n        gauge: this.gauge\n      });\n      this.updateValue();\n    }\n\n    ngOnChanges(changes) {\n      if (changes['value']) {\n        this.updateValue();\n      }\n    }\n\n    updateValue() {\n      if (this.gauge) {\n        if (this.animated) {\n          this.gauge.setValueAnimated(this.value, this.animationDuration);\n        } else {\n          this.gauge.setValue(this.value);\n        }\n      }\n    }\n\n  }\n\n  GaugeComponent.ɵfac = function GaugeComponent_Factory(t) {\n    return new (t || GaugeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(GaugeDefaults));\n  };\n\n  GaugeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: GaugeComponent,\n    selectors: [[\"mwl-gauge\"]],\n    inputs: {\n      dialStartAngle: \"dialStartAngle\",\n      dialEndAngle: \"dialEndAngle\",\n      dialRadius: \"dialRadius\",\n      min: \"min\",\n      max: \"max\",\n      label: \"label\",\n      color: \"color\",\n      showValue: \"showValue\",\n      gaugeClass: \"gaugeClass\",\n      dialClass: \"dialClass\",\n      valueDialClass: \"valueDialClass\",\n      valueClass: \"valueClass\",\n      value: \"value\",\n      animated: \"animated\",\n      animationDuration: \"animationDuration\"\n    },\n    outputs: {\n      gaugeCreated: \"gaugeCreated\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function GaugeComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return GaugeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst USER_DEFAULTS = new InjectionToken('gauge defaults');\n\nfunction defaultsFactory(userDefaults) {\n  const defaults = new GaugeDefaults();\n  Object.assign(defaults, userDefaults);\n  return defaults;\n}\n\nlet GaugeModule = /*#__PURE__*/(() => {\n  class GaugeModule {\n    static forRoot(userDefaults = {}) {\n      return {\n        ngModule: GaugeModule,\n        providers: [{\n          provide: USER_DEFAULTS,\n          useValue: userDefaults\n        }, {\n          provide: GaugeDefaults,\n          useFactory: defaultsFactory,\n          deps: [USER_DEFAULTS]\n        }]\n      };\n    }\n\n  }\n\n  GaugeModule.ɵfac = function GaugeModule_Factory(t) {\n    return new (t || GaugeModule)();\n  };\n\n  GaugeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: GaugeModule\n  });\n  GaugeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return GaugeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GaugeModule, {\n    declarations: [GaugeComponent],\n    exports: [GaugeComponent]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { GaugeModule, USER_DEFAULTS, defaultsFactory, GaugeComponent as ɵa, GaugeDefaults as ɵb }; //# sourceMappingURL=angular-gauge.js.map","map":null,"metadata":{},"sourceType":"module"}