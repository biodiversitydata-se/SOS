{"ast":null,"code":"/*!\n* chartjs-plugin-annotation v1.4.0\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2022 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { defined, distanceBetweenPoints, callback, isFinite, valueOrDefault, isObject, toRadians, toFont, isArray, addRoundedRectPath, toTRBLCorners, toPadding, PI, drawPoint, RAD_PER_DEG, clipArea, unclipArea } from 'chart.js/helpers';\nconst clickHooks = ['click', 'dblclick'];\nconst moveHooks = ['enter', 'leave'];\nconst hooks = clickHooks.concat(moveHooks);\n\nfunction updateListeners(chart, state, options) {\n  state.listened = false;\n  state.moveListened = false;\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    } else if (defined(state.listeners[hook])) {\n      delete state.listeners[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened) {\n        clickHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n          }\n        });\n      }\n\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        handleMoveEvents(state, event);\n        break;\n\n      case 'click':\n        handleClickEvents(state, event, options);\n        break;\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let element;\n\n  if (event.type === 'mousemove') {\n    element = getNearestItem(state.elements, event);\n  }\n\n  const previous = state.hovered;\n  state.hovered = element;\n  dispatchMoveEvents(state, {\n    previous,\n    element\n  }, event);\n}\n\nfunction dispatchMoveEvents(state, elements, event) {\n  const {\n    previous,\n    element\n  } = elements;\n\n  if (previous && previous !== element) {\n    dispatchEvent(previous.options.leave || state.listeners.leave, previous, event);\n  }\n\n  if (element && element !== previous) {\n    dispatchEvent(element.options.enter || state.listeners.enter, element, event);\n  }\n}\n\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const element = getNearestItem(state.elements, event);\n\n  if (element) {\n    const elOpts = element.options;\n    const dblclick = elOpts.dblclick || listeners.dblclick;\n    const click = elOpts.click || listeners.click;\n\n    if (element.clickTimeout) {\n      // 2nd click before timeout, so its a double click\n      clearTimeout(element.clickTimeout);\n      delete element.clickTimeout;\n      dispatchEvent(dblclick, element, event);\n    } else if (dblclick) {\n      // if there is a dblclick handler, wait for dblClickSpeed ms before deciding its a click\n      element.clickTimeout = setTimeout(() => {\n        delete element.clickTimeout;\n        dispatchEvent(click, element, event);\n      }, options.dblClickSpeed);\n    } else {\n      // no double click handler, just call the click handler directly\n      dispatchEvent(click, element, event);\n    }\n  }\n}\n\nfunction dispatchEvent(handler, element, event) {\n  callback(handler, [element.$context, event]);\n}\n\nfunction getNearestItem(elements, position) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return elements.filter(element => element.options.display && element.inRange(position.x, position.y)).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const distance = distanceBetweenPoints(position, center);\n\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1)[0]; // return only the top item\n}\n\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    if (annotation[key] && !scales[annotation[key]] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${annotation[key]}' for annotation '${annotation.id}'`);\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n\n  const axis = key.charAt(0);\n\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getScaleLimits(scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (annotation[scaleIDOption] === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\n\nconst EPSILON = 0.001;\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n\n  return obj;\n}\n\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n\n  const hBorderWidth = borderWidth / 2 || 0;\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);\n}\n\nfunction inBoxRange(mouseX, mouseY, {\n  x,\n  y,\n  width,\n  height\n}, borderWidth) {\n  const hBorderWidth = borderWidth / 2;\n  return mouseX >= x - hBorderWidth - EPSILON && mouseX <= x + width + hBorderWidth + EPSILON && mouseY >= y - hBorderWidth - EPSILON && mouseY <= y + height + hBorderWidth + EPSILON;\n}\n\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {\n    x,\n    y\n  } = element.getProps(['x', 'y'], useFinalPosition);\n  return {\n    x,\n    y\n  };\n}\n\nconst isOlderPart = (act, req) => req > act || act.length > req.length && act.substr(0, req.length) === req;\n\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nconst isPercentString = s => typeof s === 'string' && s.endsWith('%');\n\nconst toPercent = s => clamp(parseFloat(s) / 100, 0, 1);\n\nfunction getRelativePosition(size, positionOption) {\n  if (positionOption === 'start') {\n    return 0;\n  }\n\n  if (positionOption === 'end') {\n    return size;\n  }\n\n  if (isPercentString(positionOption)) {\n    return toPercent(positionOption) * size;\n  }\n\n  return size / 2;\n}\n\nfunction getSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return toPercent(value) * size;\n  }\n\n  return size;\n}\n\nfunction calculateTextAlignment(size, options) {\n  const {\n    x,\n    width\n  } = size;\n  const textAlign = options.textAlign;\n\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n\n  return x;\n}\n\nfunction toPosition(value) {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, 'center'),\n      y: valueOrDefault(value.y, 'center')\n    };\n  }\n\n  value = valueOrDefault(value, 'center');\n  return {\n    x: value,\n    y: value\n  };\n}\n\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nconst widthCache = new Map();\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\n\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Element} element - annotation element to use for applying the translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\n\n\nfunction translate(ctx, element, rotation) {\n  if (rotation) {\n    const center = element.getCenterPoint();\n    ctx.translate(center.x, center.y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-center.x, -center.y);\n  }\n}\n/**\n * Apply border options to the canvas context before drawing a shape\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options with border configuration\n * @returns {boolean} true is the border options have been applied\n */\n\n\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n/**\n * Apply shadow options to the canvas context before drawing a shape\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options with shadow configuration\n */\n\n\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n/**\n * Measure the label size using the label options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Object} options - options to configure the label\n * @returns {{width: number, height: number}} the measured size of the label\n */\n\n\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n\n  const font = toFont(options.font);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + font.string + strokeWidth + (ctx._measureText ? '-spriting' : '');\n\n  if (!widthCache.has(mapKey)) {\n    ctx.save();\n    ctx.font = font.string;\n    const count = lines.length;\n    let width = 0;\n\n    for (let i = 0; i < count; i++) {\n      const text = lines[i];\n      width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    }\n\n    ctx.restore();\n    const height = count * font.lineHeight + strokeWidth;\n    widthCache.set(mapKey, {\n      width,\n      height\n    });\n  }\n\n  return widthCache.get(mapKey);\n}\n/**\n * Draw a box with the size and the styling options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {{x: number, y: number, width: number, height: number}} rect - rect to draw\n * @param {Object} options - options to style the box\n * @returns {undefined}\n */\n\n\nfunction drawBox(ctx, rect, options) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x,\n    y,\n    w: width,\n    h: height,\n    // TODO: v2 remove support for cornerRadius\n    radius: clampAll(toTRBLCorners(valueOrDefault(options.cornerRadius, options.borderRadius)), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n\n  ctx.restore();\n}\n/**\n * Draw a label with the size and the styling options.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {{x: number, y: number, width: number, height: number}} rect - rect to map teh label\n * @param {Object} options - options to style the label\n * @returns {undefined}\n */\n\n\nfunction drawLabel(ctx, rect, options) {\n  const content = options.content;\n\n  if (isImageOrCanvas(content)) {\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    return;\n  }\n\n  const labels = isArray(content) ? content : [content];\n  const font = toFont(options.font);\n  const lh = font.lineHeight;\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + lh / 2 + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.font = font.string;\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n\n  if (setTextStrokeStyle(ctx, options)) {\n    labels.forEach((l, i) => ctx.strokeText(l, x, y + i * lh));\n  }\n\n  ctx.fillStyle = options.color;\n  labels.forEach((l, i) => ctx.fillText(l, x, y + i * lh));\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @returns {Point}\n */\n\n\nfunction getRectCenterPoint(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    x: x + width / 2,\n    y: y + height / 2\n  };\n}\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\n\n\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\n\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n/**\n * @param {Scale} scale\n * @param {{start: number, end: number}} options\n * @returns {{start: number, end: number}}\n */\n\n\nfunction getChartDimensionByScale(scale, options) {\n  if (scale) {\n    const min = scaleValue(scale, options.min, options.start);\n    const max = scaleValue(scale, options.max, options.end);\n    return {\n      start: Math.min(min, max),\n      end: Math.max(min, max)\n    };\n  }\n\n  return {\n    start: options.start,\n    end: options.end\n  };\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\n\n\nfunction getChartPoint(chart, options) {\n  const {\n    chartArea,\n    scales\n  } = chart;\n  const xScale = scales[options.xScaleID];\n  const yScale = scales[options.yScaleID];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, x);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, y);\n  }\n\n  return {\n    x,\n    y\n  };\n}\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {{x?:number, y?: number, x2?: number, y2?: number, width?: number, height?: number}}\n */\n\n\nfunction getChartRect(chart, options) {\n  const xScale = chart.scales[options.xScaleID];\n  const yScale = chart.scales[options.yScaleID];\n  let {\n    top: y,\n    left: x,\n    bottom: y2,\n    right: x2\n  } = chart.chartArea;\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  const xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y,\n    end: y2\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y\n  };\n}\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions} options\n */\n\n\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  return {\n    x: point.x + options.xAdjust,\n    y: point.y + options.yAdjust,\n    width: options.radius * 2,\n    height: options.radius * 2\n  };\n}\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions} options\n * @returns\n */\n\n\nfunction resolvePointPosition(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = getChartRect(chart, options);\n    const point = getRectCenterPoint(box);\n    let radius = options.radius;\n\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n\n    return {\n      x: point.x + options.xAdjust,\n      y: point.y + options.yAdjust,\n      width: radius * 2,\n      height: radius * 2\n    };\n  }\n\n  return getChartCircle(chart, options);\n}\n\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange(x, y, this.getProps(['x', 'y', 'width', 'height'], useFinalPosition), this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n  }\n\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this, this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n\n  drawLabel(ctx) {\n    const {\n      x,\n      y,\n      width,\n      height,\n      options\n    } = this;\n    const {\n      label,\n      borderWidth\n    } = options;\n    const halfBorder = borderWidth / 2;\n    const position = toPosition(label.position);\n    const padding = toPadding(label.padding);\n    const labelSize = measureLabelSize(ctx, label);\n    const labelRect = {\n      x: calculateX(this, labelSize, position, padding),\n      y: calculateY(this, labelSize, position, padding),\n      width: labelSize.width,\n      height: labelSize.height\n    };\n    ctx.save();\n    translate(ctx, this, label.rotation);\n    ctx.beginPath();\n    ctx.rect(x + halfBorder + padding.left, y + halfBorder + padding.top, width - borderWidth - padding.width, height - borderWidth - padding.height);\n    ctx.clip();\n    drawLabel(ctx, labelRect, label);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    return getChartRect(chart, options);\n  }\n\n}\n\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  cornerRadius: undefined,\n  // TODO: v2 remove support for cornerRadius\n  display: true,\n  label: {\n    borderWidth: undefined,\n    color: 'black',\n    content: null,\n    drawTime: undefined,\n    enabled: false,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    xAdjust: 0,\n    yAdjust: 0,\n    width: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction calculateX(box, labelSize, position, padding) {\n  const {\n    x: start,\n    x2: end,\n    width: size,\n    options\n  } = box;\n  const {\n    xAdjust: adjust,\n    borderWidth\n  } = options.label;\n  return calculatePosition$1({\n    start,\n    end,\n    size\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust,\n    borderWidth,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY(box, labelSize, position, padding) {\n  const {\n    y: start,\n    y2: end,\n    height: size,\n    options\n  } = box;\n  const {\n    yAdjust: adjust,\n    borderWidth\n  } = options.label;\n  return calculatePosition$1({\n    start,\n    end,\n    size\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust,\n    borderWidth,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  const {\n    start,\n    end\n  } = boxOpts;\n  const {\n    position,\n    padding: {\n      start: padStart,\n      end: padEnd\n    },\n    adjust,\n    borderWidth\n  } = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + padStart + getRelativePosition(availableSize, position);\n}\n\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\n\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\n\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\n\nconst sqr = v => v * v;\n\nconst defaultEpsilon = 0.001;\n\nfunction isLineInArea({\n  x,\n  y,\n  x2,\n  y2\n}, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\n\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n\n  return {\n    x,\n    y\n  };\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\n\nlet LineAnnotation = /*#__PURE__*/(() => {\n  class LineAnnotation extends Element {\n    // TODO: make private in v2\n    intersects(x, y, epsilon = defaultEpsilon, useFinalPosition) {\n      // Adapted from https://stackoverflow.com/a/6853926/25507\n      const {\n        x: x1,\n        y: y1,\n        x2,\n        y2\n      } = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n      const dx = x2 - x1;\n      const dy = y2 - y1;\n      const lenSq = sqr(dx) + sqr(dy);\n      const t = lenSq === 0 ? -1 : ((x - x1) * dx + (y - y1) * dy) / lenSq;\n      let xx, yy;\n\n      if (t < 0) {\n        xx = x1;\n        yy = y1;\n      } else if (t > 1) {\n        xx = x2;\n        yy = y2;\n      } else {\n        xx = x1 + t * dx;\n        yy = y1 + t * dy;\n      }\n\n      return sqr(x - xx) + sqr(y - yy) <= epsilon;\n    }\n    /**\n     * @todo make private in v2\n     * @param {boolean} useFinalPosition - use the element's animation target instead of current position\n     * @param {top, right, bottom, left} [chartArea] - optional, area of the chart\n     * @returns {boolean} true if the label is visible\n     */\n\n\n    labelIsVisible(useFinalPosition, chartArea) {\n      const labelOpts = this.options.label;\n\n      if (!labelOpts || !labelOpts.enabled) {\n        return false;\n      }\n\n      return !chartArea || isLineInArea(this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), chartArea);\n    } // TODO: make private in v2\n\n\n    isOnLabel(mouseX, mouseY, useFinalPosition) {\n      if (!this.labelIsVisible(useFinalPosition)) {\n        return false;\n      }\n\n      const {\n        labelX,\n        labelY,\n        labelWidth,\n        labelHeight,\n        labelRotation\n      } = this.getProps(['labelX', 'labelY', 'labelWidth', 'labelHeight', 'labelRotation'], useFinalPosition);\n      const {\n        x,\n        y\n      } = rotated({\n        x: mouseX,\n        y: mouseY\n      }, {\n        x: labelX,\n        y: labelY\n      }, -labelRotation);\n      const hBorderWidth = this.options.label.borderWidth / 2 || 0;\n      const w2 = labelWidth / 2 + hBorderWidth;\n      const h2 = labelHeight / 2 + hBorderWidth;\n      return x >= labelX - w2 - defaultEpsilon && x <= labelX + w2 + defaultEpsilon && y >= labelY - h2 - defaultEpsilon && y <= labelY + h2 + defaultEpsilon;\n    }\n\n    inRange(mouseX, mouseY, useFinalPosition) {\n      const epsilon = sqr(this.options.borderWidth / 2);\n      return this.intersects(mouseX, mouseY, epsilon, useFinalPosition) || this.isOnLabel(mouseX, mouseY, useFinalPosition);\n    }\n\n    getCenterPoint() {\n      return {\n        x: (this.x2 + this.x) / 2,\n        y: (this.y2 + this.y) / 2\n      };\n    }\n\n    draw(ctx) {\n      const {\n        x,\n        y,\n        x2,\n        y2,\n        options\n      } = this;\n      ctx.save();\n\n      if (!setBorderStyle(ctx, options)) {\n        // no border width, then line is not drawn\n        return ctx.restore();\n      }\n\n      setShadowStyle(ctx, options);\n      const angle = Math.atan2(y2 - y, x2 - x);\n      const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n      const {\n        startOpts,\n        endOpts,\n        startAdjust,\n        endAdjust\n      } = getArrowHeads(this);\n      ctx.translate(x, y);\n      ctx.rotate(angle);\n      ctx.beginPath();\n      ctx.moveTo(0 + startAdjust, 0);\n      ctx.lineTo(length - endAdjust, 0);\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n      drawArrowHead(ctx, 0, startAdjust, startOpts);\n      drawArrowHead(ctx, length, -endAdjust, endOpts);\n      ctx.restore();\n    }\n\n    drawLabel(ctx, chartArea) {\n      if (!this.labelIsVisible(false, chartArea)) {\n        return;\n      }\n\n      const {\n        labelX,\n        labelY,\n        labelWidth,\n        labelHeight,\n        labelRotation,\n        labelPadding,\n        labelTextSize,\n        options: {\n          label\n        }\n      } = this;\n      ctx.save();\n      ctx.translate(labelX, labelY);\n      ctx.rotate(labelRotation);\n      const boxRect = {\n        x: -(labelWidth / 2),\n        y: -(labelHeight / 2),\n        width: labelWidth,\n        height: labelHeight\n      };\n      drawBox(ctx, boxRect, label);\n      const labelTextRect = {\n        x: -(labelWidth / 2) + labelPadding.left + label.borderWidth / 2,\n        y: -(labelHeight / 2) + labelPadding.top + label.borderWidth / 2,\n        width: labelTextSize.width,\n        height: labelTextSize.height\n      };\n      drawLabel(ctx, labelTextRect, label);\n      ctx.restore();\n    }\n\n    resolveElementProperties(chart, options) {\n      const scale = chart.scales[options.scaleID];\n      let {\n        top: y,\n        left: x,\n        bottom: y2,\n        right: x2\n      } = chart.chartArea;\n      let min, max;\n\n      if (scale) {\n        min = scaleValue(scale, options.value, NaN);\n        max = scaleValue(scale, options.endValue, min);\n\n        if (scale.isHorizontal()) {\n          x = min;\n          x2 = max;\n        } else {\n          y = min;\n          y2 = max;\n        }\n      } else {\n        const xScale = chart.scales[options.xScaleID];\n        const yScale = chart.scales[options.yScaleID];\n\n        if (xScale) {\n          x = scaleValue(xScale, options.xMin, x);\n          x2 = scaleValue(xScale, options.xMax, x2);\n        }\n\n        if (yScale) {\n          y = scaleValue(yScale, options.yMin, y);\n          y2 = scaleValue(yScale, options.yMax, y2);\n        }\n      }\n\n      const inside = isLineInArea({\n        x,\n        y,\n        x2,\n        y2\n      }, chart.chartArea);\n      const properties = inside ? limitLineToArea({\n        x,\n        y\n      }, {\n        x: x2,\n        y: y2\n      }, chart.chartArea) : {\n        x,\n        y,\n        x2,\n        y2,\n        width: Math.abs(x2 - x),\n        height: Math.abs(y2 - y)\n      };\n      const label = options.label;\n\n      if (label && label.content) {\n        return loadLabelRect(properties, chart, label);\n      }\n\n      return properties;\n    }\n\n  }\n\n  LineAnnotation.id = 'lineAnnotation';\n  return LineAnnotation;\n})();\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  enabled: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    enabled: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  display: true,\n  endValue: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    color: '#fff',\n    content: null,\n    cornerRadius: undefined,\n    // TODO: v2 remove support for cornerRadius\n    drawTime: undefined,\n    enabled: false,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    xPadding: undefined,\n    // TODO: v2 remove support for xPadding\n    yAdjust: 0,\n    yPadding: undefined // TODO: v2 remove support for yPadding\n\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction loadLabelRect(line, chart, options) {\n  // TODO: v2 remove support for xPadding and yPadding\n  const {\n    padding: lblPadding,\n    xPadding,\n    yPadding,\n    borderWidth\n  } = options;\n  const padding = getPadding(lblPadding, xPadding, yPadding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  const labelRect = calculateLabelPosition(line, options, {\n    width,\n    height,\n    padding\n  }, chart.chartArea);\n  line.labelX = labelRect.x;\n  line.labelY = labelRect.y;\n  line.labelWidth = labelRect.width;\n  line.labelHeight = labelRect.height;\n  line.labelRotation = labelRect.rotation;\n  line.labelPadding = padding;\n  line.labelTextSize = textSize;\n  return line;\n}\n\nfunction calculateAutoRotation(line) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = line;\n  const rotation = Math.atan2(y2 - y, x2 - x); // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n} // TODO: v2 remove support for xPadding and yPadding\n\n\nfunction getPadding(padding, xPadding, yPadding) {\n  let tempPadding = padding;\n\n  if (xPadding || yPadding) {\n    tempPadding = {\n      x: xPadding || 6,\n      y: yPadding || 6\n    };\n  }\n\n  return toPadding(tempPadding);\n}\n\nfunction calculateLabelPosition(line, label, sizes, chartArea) {\n  const {\n    width,\n    height,\n    padding\n  } = sizes;\n  const {\n    xAdjust,\n    yAdjust\n  } = label;\n  const p1 = {\n    x: line.x,\n    y: line.y\n  };\n  const p2 = {\n    x: line.x2,\n    y: line.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(line) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(line, label, {\n    labelSize: size,\n    padding\n  }, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  return {\n    x: adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust,\n    y: adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust,\n    width,\n    height,\n    rotation\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(line, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(line, chartArea);\n\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: line.x2 - line.x,\n      h: line.y2 - line.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: line.x - line.x2,\n      h: line.y - line.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {\n    labelSize,\n    padding\n  } = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(line, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = line;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.enabled) {\n    return 0;\n  }\n\n  const {\n    length,\n    width\n  } = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {\n    x: length,\n    y: width + adjust\n  };\n  const p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.enabled) {\n    return;\n  }\n\n  const {\n    length,\n    width,\n    fill,\n    backgroundColor,\n    borderColor\n  } = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n\n  ctx.stroke();\n}\n\nclass EllipseAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return pointInEllipse({\n      x: mouseX,\n      y: mouseY\n    }, this.getProps(['width', 'height'], useFinalPosition), this.options.rotation, this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n  }\n\n  draw(ctx) {\n    const {\n      width,\n      height,\n      options\n    } = this;\n    const center = this.getCenterPoint();\n    ctx.save();\n    translate(ctx, this, options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(center.x, center.y, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    return getChartRect(chart, options);\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y'\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  const {\n    width,\n    height\n  } = ellipse;\n  const center = ellipse.getCenterPoint(true);\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  } // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n\n\n  const angle = toRadians(rotation || 0);\n  const hBorderWidth = borderWidth / 2 || 0;\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - center.x) + sinAngle * (p.y - center.y), 2);\n  const b = Math.pow(sinAngle * (p.x - center.x) - cosAngle * (p.y - center.y), 2);\n  return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;\n}\n\nclass LabelAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange(x, y, this.getProps(['x', 'y', 'width', 'height'], useFinalPosition), this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getRectCenterPoint(this.getProps(['x', 'y', 'width', 'height'], useFinalPosition));\n  }\n\n  draw(ctx) {\n    if (!this.options.content) {\n      return;\n    }\n\n    const {\n      labelX,\n      labelY,\n      labelWidth,\n      labelHeight,\n      options\n    } = this;\n    ctx.save();\n    translate(ctx, this, options.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, {\n      x: labelX,\n      y: labelY,\n      width: labelWidth,\n      height: labelHeight\n    }, options);\n    ctx.restore();\n  } // TODO: make private in v2\n\n\n  resolveElementProperties(chart, options) {\n    const point = !isBoundToPoint(options) ? getRectCenterPoint(getChartRect(chart, options)) : getChartPoint(chart, options);\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureRect(point, labelSize, options, padding);\n    const hBorderWidth = options.borderWidth / 2;\n    const properties = {\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      labelX: boxSize.x + padding.left + hBorderWidth,\n      labelY: boxSize.y + padding.top + hBorderWidth,\n      labelWidth: labelSize.width,\n      labelHeight: labelSize.height\n    };\n    properties.calloutPosition = options.callout.enabled && resolveCalloutPosition(properties, options.callout, options.rotation);\n    return properties;\n  }\n\n}\n\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    enabled: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction measureRect(point, size, options, padding) {\n  const width = size.width + padding.width + options.borderWidth;\n  const height = size.height + padding.height + options.borderWidth;\n  const position = toPosition(options.position);\n  return {\n    x: calculatePosition(point.x, width, options.xAdjust, position.x),\n    y: calculatePosition(point.y, height, options.yAdjust, position.y),\n    width,\n    height\n  };\n}\n\nfunction calculatePosition(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\n\nfunction drawCallout(ctx, element) {\n  const {\n    pointX,\n    pointY,\n    calloutPosition,\n    options\n  } = element;\n\n  if (!calloutPosition || element.inRange(pointX, pointY)) {\n    return;\n  }\n\n  const callout = options.callout;\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n\n  if (!stroke) {\n    return ctx.restore();\n  }\n\n  const {\n    separatorStart,\n    separatorEnd\n  } = getCalloutSeparatorCoord(element, calloutPosition);\n  const {\n    sideStart,\n    sideEnd\n  } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-options.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: separatorStart.y + height\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: separatorStart.x + width,\n      y: separatorStart.y\n    };\n  }\n\n  return {\n    separatorStart,\n    separatorEnd\n  };\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {\n    width,\n    height,\n    options\n  } = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {\n    y,\n    width,\n    height,\n    options\n  } = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n\n  return {\n    sideStart,\n    sideEnd\n  };\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n\n  return side;\n}\n\nfunction resolveCalloutPosition(properties, options, rotation) {\n  const position = options.position;\n\n  if (position === 'left' || position === 'right' || position === 'top' || position === 'bottom') {\n    return position;\n  }\n\n  return resolveCalloutAutoPosition(properties, options, rotation);\n}\n\nconst positions = ['left', 'bottom', 'top', 'right'];\n\nfunction resolveCalloutAutoPosition(properties, options, rotation) {\n  const {\n    x,\n    y,\n    width,\n    height,\n    pointX,\n    pointY\n  } = properties;\n  const center = {\n    x: x + width / 2,\n    y: y + height / 2\n  };\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x + width];\n  const yPoints = [y + yAdjust, y + height, y, y + yAdjust];\n  const result = [];\n\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\n\nclass PointAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const {\n      width\n    } = this.getProps(['width'], useFinalPosition);\n    return inPointRange({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), width / 2, this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n\n    if (options.radius < 0.1) {\n      return;\n    }\n\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    options.borderWidth = 0;\n    drawPoint(ctx, options, this.x, this.y);\n\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolvePointPosition(chart, options);\n  }\n\n}\n\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nclass PolygonAnnotation extends Element {\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {\n      elements,\n      options\n    } = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(); // If no border, don't draw it\n\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = resolvePointPosition(chart, options);\n    const {\n      sides,\n      radius,\n      rotation,\n      borderWidth\n    } = options;\n    const halfBorder = borderWidth / 2;\n    const elements = [];\n    const angle = 2 * PI / sides;\n    let rad = rotation * RAD_PER_DEG;\n\n    for (let i = 0; i < sides; i++, rad += angle) {\n      const sin = Math.sin(rad);\n      const cos = Math.cos(rad);\n      elements.push({\n        type: 'point',\n        optionScope: 'point',\n        properties: {\n          x: x + sin * radius,\n          y: y - cos * radius,\n          bX: x + sin * (radius + halfBorder),\n          bY: y - cos * (radius + halfBorder)\n        }\n      });\n    }\n\n    return {\n      x,\n      y,\n      width,\n      height,\n      elements,\n      initProperties: {\n        x,\n        y\n      }\n    };\n  }\n\n}\n\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: 'x',\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: 'y',\n  yValue: undefined\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n\n    if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n\n    A = B;\n  }\n\n  return isInside;\n}\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\n\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation'\n  });\n});\nconst directUpdater = {\n  update: Object.assign\n};\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\n\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n/**\n * Create or update all annotation elements, configured to the plugin.\n * @param {Chart} chart - the chart where the plugin is enabled\n * @param {Object} state - the state of the plugin\n * @param {Object} options - annotation options to use\n * @param {UpdateMode} mode - The update mode\n */\n\n\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties, resolver, animations); // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, {\n  elements,\n  initProperties\n}, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n\n    if (isObject(initProperties)) {\n      Object.assign(element, initProperties);\n    }\n  }\n\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    result[prop] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n\n  return elements;\n}\n\nvar name = \"chartjs-plugin-annotation\";\nvar version = \"1.4.0\";\nconst chartStates = new Map();\nvar annotation = {\n  id: 'annotation',\n  version,\n\n  /* TODO: enable in v2\n  beforeRegister() {\n    requireVersion('chart.js', '3.7', Chart.version);\n  },\n  */\n  afterRegister() {\n    Chart.register(annotationTypes); // TODO: Remove this check, warning and workaround in v2\n\n    if (!requireVersion('chart.js', '3.7', Chart.version, false)) {\n      console.warn(`${name} has known issues with chart.js versions prior to 3.7, please consider upgrading.`); // Workaround for https://github.com/chartjs/chartjs-plugin-annotation/issues/572\n\n      Chart.defaults.set('elements.lineAnnotation', {\n        callout: {},\n        font: {},\n        padding: 6\n      });\n    }\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n\n    verifyScaleOptions(annotations, chart.scales);\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    handleEvent(state, args.event, options);\n  },\n\n  destroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'pointX', 'pointY', 'labelX', 'labelY', 'labelWidth', 'labelHeight', 'radius'],\n        type: 'number'\n      }\n    },\n    clip: true,\n    dblClickSpeed: 350,\n    // ms\n    drawTime: 'afterDatasetsDraw',\n    label: {\n      drawTime: null\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    }\n  },\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const {\n    visibleElements\n  } = chartStates.get(chart);\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  drawElements(ctx, visibleElements, caller);\n  drawSubElements(ctx, visibleElements, caller);\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n\n  visibleElements.forEach(el => {\n    if (!('drawLabel' in el)) {\n      return;\n    }\n\n    const label = el.options.label;\n\n    if (label && label.enabled && label.content && (label.drawTime || el.options.drawTime) === caller) {\n      el.drawLabel(ctx, chartArea);\n    }\n  });\n}\n\nfunction drawElements(ctx, elements, caller) {\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      el.draw(ctx);\n    }\n  }\n}\n\nfunction drawSubElements(ctx, elements, caller) {\n  for (const el of elements) {\n    if (isArray(el.elements)) {\n      drawElements(ctx, el.elements, caller);\n    }\n  }\n}\n\nexport { annotation as default };","map":null,"metadata":{},"sourceType":"module"}