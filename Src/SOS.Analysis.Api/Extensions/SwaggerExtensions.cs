using Asp.Versioning;
using Asp.Versioning.ApiExplorer;
using Microsoft.AspNetCore.Mvc.Abstractions;
using Microsoft.AspNetCore.Mvc.ApiExplorer;
using Microsoft.Extensions.Options;
using Microsoft.OpenApi.Models;
using NetTopologySuite.Geometries;
using SOS.Lib.ActionFilters;
using SOS.Lib.Swagger;
using Swashbuckle.AspNetCore.SwaggerGen;
using Swashbuckle.AspNetCore.SwaggerUI;
using System.Reflection;

namespace SOS.Analysis.Api.Extensions;

public static class SwaggerExtensions
{
    const string InternalApiName = "InternalSosAnalysis";
    const string PublicApiName = "PublicSosAnalysis";
    const string InternalApiPrefix = "Internal";

    public static IServiceCollection SetupSwagger(this IServiceCollection services)
    {
        services.AddApiVersioning(options =>
        {
            options.DefaultApiVersion = new ApiVersion(1, 5);
            options.AssumeDefaultVersionWhenUnspecified = true;
            options.ReportApiVersions = true;
            options.ApiVersionReader = new HeaderApiVersionReader("X-Api-Version");
        }).AddApiExplorer(options =>
        {
            // add the versioned api explorer, which also adds IApiVersionDescriptionProvider service
            // note: the specified format code will format the version as "'v'major[.minor][-status]"
            options.GroupNameFormat = "'v'VV";
            // note: this option is only necessary when versioning by url segment. the SubstitutionFormat
            // can also be used to control the format of the API version in route templates
            options.SubstituteApiVersionInUrl = true;
        });

        services.AddTransient<IConfigureOptions<SwaggerGenOptions>, ConfigureSwaggerOptions>();

        services.AddSwaggerGen(options =>
        {
            options.MapType<Geometry>(() => new OpenApiSchema { Type = "object" });
            var currentAssembly = Assembly.GetExecutingAssembly();
            var xmlDocs = currentAssembly.GetReferencedAssemblies()
                .Union(new AssemblyName[] { currentAssembly.GetName() })
                .Select(a => Path.Combine(Path.GetDirectoryName(currentAssembly!.Location) ?? "", $"{a.Name}.xml"))
                .Where(f => File.Exists(f)).ToArray();

            Array.ForEach(xmlDocs, (d) =>
            {
                options.IncludeXmlComments(d);
            });

            options.UseInlineDefinitionsForEnums();

            // add a custom operation filters
            options.OperationFilter<SwaggerDefaultValues>();
            options.OperationFilter<SwaggerAddOptionalHeaderParameters>();

            options.SchemaFilter<SwaggerIgnoreFilter>();
            // Post-modify Operation descriptions once they've been generated by wiring up one or more
            // Operation filters.
            options.OperationFilter<ApiManagementDocumentationFilter>();

            options.DocInclusionPredicate((documentName, apiDescription) =>
            {
                var apiVersions = GetApiVersions(apiDescription);
                bool isEndpointInternalApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(InternalApiAttribute));
                if (isEndpointInternalApi && !documentName.StartsWith(InternalApiPrefix)) return false;
                return apiVersions.Any(v =>
                           $"{InternalApiName}v{v}" == documentName) ||
                       apiVersions.Any(v =>
                           $"{PublicApiName}v{v}" == documentName);
            });

            options.AddSecurityDefinition("Bearer", //Name the security scheme
                new OpenApiSecurityScheme
                {
                    Name = "Authorization",
                    Description = "JWT Authorization header using the Bearer scheme.",
                    In = ParameterLocation.Header,
                    Type = SecuritySchemeType.Http, //We set the scheme type to http since we're using bearer authentication
                    Scheme = "bearer" //The name of the HTTP Authorization scheme to be used in the Authorization header. In this case "bearer".
                });

            options.AddSecurityRequirement(new OpenApiSecurityRequirement
            {
                {
                    new OpenApiSecurityScheme{
                        Scheme = "bearer",
                        Name = "Bearer",
                        In = ParameterLocation.Header,
                        Reference = new OpenApiReference{
                            Id = "Bearer", //The name of the previously defined security scheme.
                            Type = ReferenceType.SecurityScheme
                        }
                    },
                    new List<string>()
                }
            });
        });

        return services;
    }

    public static WebApplication ApplyUseSwaggerUI(this WebApplication app)
    {
        var apiVersionDescriptionProvider = app.Services.GetRequiredService<IApiVersionDescriptionProvider>();
        app.UseSwaggerUI(options =>
        {
            foreach (var description in apiVersionDescriptionProvider.ApiVersionDescriptions)
            {
                options.SwaggerEndpoint(
                    $"/swagger/{InternalApiName}{description.GroupName}/swagger.json",
                    $"SOS Analysis API (Internal) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                    $"/swagger/{PublicApiName}{description.GroupName}/swagger.json",
                    $"SOS Analysis API (Public) {description.GroupName.ToUpperInvariant()}");

                options.DisplayOperationId();
                options.DocExpansion(DocExpansion.None);
            }
        });

        return app;
    }

    private static IReadOnlyList<ApiVersion> GetApiVersions(ApiDescription apiDescription)
    {
        var apiVersionMetadata = apiDescription.ActionDescriptor.GetApiVersionMetadata();
        var actionApiVersionModel = apiVersionMetadata.Map(ApiVersionMapping.Explicit | ApiVersionMapping.Implicit);

        var apiVersions = actionApiVersionModel.DeclaredApiVersions.Any()
            ? actionApiVersionModel.DeclaredApiVersions
            : actionApiVersionModel.ImplementedApiVersions;
        return apiVersions;
    }

    private class ConfigureSwaggerOptions : IConfigureOptions<SwaggerGenOptions>
    {
        readonly IApiVersionDescriptionProvider provider;

        public ConfigureSwaggerOptions(IApiVersionDescriptionProvider provider) =>
        this.provider = provider;

        public void Configure(SwaggerGenOptions options)
        {
            foreach (var description in provider.ApiVersionDescriptions)
            {
                options.SwaggerDoc(description.GroupName, new OpenApiInfo
                {
                    Version = description.ApiVersion.ToString(),
                    Title = $"API v{description.ApiVersion}",
                });

                options.SwaggerDoc(
                    $"{InternalApiName}{description.GroupName}",
                    new OpenApiInfo()
                    {
                        Title = $"SOS Analysis API (Internal) {description.GroupName.ToUpperInvariant()}",
                        Version = description.ApiVersion.ToString(),
                        Description = "Species Observation System (SOS) - Analysis API. Internal API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                    });

                options.SwaggerDoc(
                    $"{PublicApiName}{description.GroupName}",
                    new OpenApiInfo()
                    {
                        Title = $"SOS Analysis API (Public) {description.GroupName.ToUpperInvariant()}",
                        Version = description.ApiVersion.ToString(),
                        Description = "Species Observation System (SOS) - Analysis API. Public API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                    });

                options.CustomOperationIds(apiDesc =>
                {
                    apiDesc.TryGetMethodInfo(out MethodInfo methodInfo);
                    var controller = apiDesc.ActionDescriptor?.RouteValues["controller"];
                    var methodName = methodInfo.Name;
                    return $"{controller}_{methodName}".Replace("Async", "", StringComparison.InvariantCultureIgnoreCase);
                });
            }
        }
    }
}