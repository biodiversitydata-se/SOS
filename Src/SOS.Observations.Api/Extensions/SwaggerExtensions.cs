using Asp.Versioning;
using Asp.Versioning.ApiExplorer;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Mvc.Abstractions;
using Microsoft.AspNetCore.Mvc.ApiExplorer;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using Microsoft.OpenApi.Models;
using SOS.Lib.ActionFilters;
using SOS.Lib.Swagger;
using Swashbuckle.AspNetCore.SwaggerGen;
using Swashbuckle.AspNetCore.SwaggerUI;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace SOS.Observations.Api.Extensions;

public static class SwaggerExtensions
{
    const string InternalApiName = "InternalSosObservations";
    const string PublicApiName = "PublicSosObservations";
    const string AzureInternalApiName = "AzureInternalSosObservations";
    const string AzurePublicApiName = "AzurePublicSosObservations";
    const string InternalApiPrefix = "Internal";
    const string AzureApiPrefix = "Azure";

    public static IServiceCollection SetupSwagger(this IServiceCollection services)
    {
        // Add Swagger services.
        services.AddTransient<IConfigureOptions<SwaggerGenOptions>, ConfigureSwaggerOptions>();

        services.AddApiVersioning(options =>
        {
            options.DefaultApiVersion = new ApiVersion(1, 5);
            options.AssumeDefaultVersionWhenUnspecified = true;
            options.ReportApiVersions = true;
            options.ApiVersionReader = new HeaderApiVersionReader("X-Api-Version");
        }).AddApiExplorer(options =>
        {
            // add the versioned api explorer, which also adds IApiVersionDescriptionProvider service
            // note: the specified format code will format the version as "'v'major[.minor][-status]"
            options.GroupNameFormat = "'v'VV";
            // note: this option is only necessary when versioning by url segment. the SubstitutionFormat
            // can also be used to control the format of the API version in route templates
            options.SubstituteApiVersionInUrl = true;
        });


        services.AddSwaggerGen(
            options =>
            {               
                // add a custom operation filters
                options.OperationFilter<SwaggerDefaultValues>();
                options.OperationFilter<SwaggerAddOptionalHeaderParameters>();

                var currentAssembly = Assembly.GetExecutingAssembly();
                var xmlDocs = currentAssembly.GetReferencedAssemblies()
                    .Union(new AssemblyName[] { currentAssembly.GetName() })
                    .Select(a => Path.Combine(Path.GetDirectoryName(currentAssembly.Location), $"{a.Name}.xml"))
                    .Where(f => File.Exists(f)).ToArray();

                Array.ForEach(xmlDocs, (d) =>
                {
                    options.IncludeXmlComments(d);
                });

                options.SchemaFilter<SwaggerIgnoreFilter>();
                options.SchemaFilter<GeometrySchemaFilter>();
                options.SchemaFilter<PointSchemaFilter>();
                options.SchemaFilter<SwaggerForceSchemaFilter>();
                // Post-modify Operation descriptions once they've been generated by wiring up one or more
                // Operation filters.
                options.OperationFilter<ApiManagementDocumentationFilter>();               

                options.DocInclusionPredicate((documentName, apiDescription) =>
                {
                    var apiVersions = GetApiVersions(apiDescription);
                    var versionMatch = apiVersions.Any(v => $"{InternalApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{PublicApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{AzureInternalApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{AzurePublicApiName}v{v}" == documentName);
                    var isAzurePublicApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(AzureApiAttribute));
                    var isAzurePublicDocument = documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase) && !documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase);
                    var isAzureInternalApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(AzureInternalApiAttribute));
                    var isAzureInternalDocument = documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase) && documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase);
                    var isInternalApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(InternalApiAttribute));
                    var isInternalDocument = documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase) && !documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase);

                    return
                        versionMatch && (
                            (isAzurePublicApi && isAzurePublicDocument) ||
                            (isAzureInternalApi && isAzureInternalDocument)
                        ) || (
                        !isAzurePublicDocument && !isAzureInternalDocument &&
                        (isInternalDocument || !isInternalApi)
                    );
                });
                options.AddSecurityDefinition("Bearer", //Name the security scheme
                    new OpenApiSecurityScheme
                    {
                        Name = "Authorization",
                        Description = "JWT Authorization header using the Bearer scheme.",
                        In = ParameterLocation.Header,
                        Type = SecuritySchemeType.Http, //We set the scheme type to http since we're using bearer authentication
                        Scheme = "bearer" //The name of the HTTP Authorization scheme to be used in the Authorization header. In this case "bearer".
                    });

                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme{
                            Scheme = "bearer",
                            Name = "Bearer",
                            In = ParameterLocation.Header,
                            Reference = new OpenApiReference{
                                Id = "Bearer", //The name of the previously defined security scheme.
                                Type = ReferenceType.SecurityScheme
                            }
                        },
                        new List<string>()
                    }
                });
            });

        return services;
    }

    public static WebApplication ApplyUseSwaggerUI(this WebApplication app)
    {
        var apiVersionDescriptionProvider = app.Services.GetRequiredService<IApiVersionDescriptionProvider>();
        app.UseSwaggerUI(options =>
        {
            foreach (var description in apiVersionDescriptionProvider.ApiVersionDescriptions)
            {
                options.SwaggerEndpoint(
                    $"/swagger/{InternalApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Internal) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                    $"/swagger/{PublicApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Public) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                   $"/swagger/{AzureInternalApiName}{description.GroupName}/swagger.json",
                   $"SOS Observations API (Internal - Azure) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                    $"/swagger/{AzurePublicApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Public - Azure) {description.GroupName.ToUpperInvariant()}");

                options.DisplayOperationId();
                options.DocExpansion(DocExpansion.None);
            }
        });

        return app;
    }

    private static IReadOnlyList<ApiVersion> GetApiVersions(ApiDescription apiDescription)
    {
        var apiVersionMetadata = apiDescription.ActionDescriptor.GetApiVersionMetadata();
        var actionApiVersionModel = apiVersionMetadata.Map(ApiVersionMapping.Explicit | ApiVersionMapping.Implicit);

        var apiVersions = actionApiVersionModel.DeclaredApiVersions.Any()
            ? actionApiVersionModel.DeclaredApiVersions
            : actionApiVersionModel.ImplementedApiVersions;
        return apiVersions;
    }

    public class ConfigureSwaggerOptions : IConfigureOptions<SwaggerGenOptions>
    {
        readonly IApiVersionDescriptionProvider provider;
        public ConfigureSwaggerOptions(IApiVersionDescriptionProvider provider)
        {
            this.provider = provider;
        }
        public void Configure(SwaggerGenOptions options)
        {
            foreach (var description in provider.ApiVersionDescriptions)
            {
                options.SwaggerDoc(
                       $"InternalSosObservations{description.GroupName}", 
                       new OpenApiInfo
                       {
                           Title = $"SOS Observations API (Internal) {description.GroupName.ToUpperInvariant()}",
                           Version = description.ApiVersion.ToString(),
                           Description = "Species Observation System (SOS) - Observations API. Internal API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                       });
                options.SwaggerDoc(
                    $"PublicSosObservations{description.GroupName}",
                    new OpenApiInfo
                    {
                        Title = $"SOS Observations API (Public) {description.GroupName.ToUpperInvariant()}",
                        Version = description.ApiVersion.ToString(),
                        Description = "Species Observation System (SOS) - Observations API. Public API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                    });
                options.SwaggerDoc(
                       $"AzureInternalSosObservations{description.GroupName}",
                       new OpenApiInfo
                       {
                           Title = $"SOS Observations API (Internal - Azure) {description.GroupName.ToUpperInvariant()}",
                           Version = description.ApiVersion.ToString(),
                           Description = "Species Observation System (SOS) - Observations API. Internal - Azure API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                       });
                options.SwaggerDoc(
                    $"AzurePublicSosObservations{description.GroupName}",
                    new OpenApiInfo
                    {
                        Title = $"SOS Observations API (Public - Azure) {description.GroupName.ToUpperInvariant()}",
                        Version = description.ApiVersion.ToString(),
                        Description = "Species Observation System (SOS) - Observations API. Public - Azure API." + (description.IsDeprecated ? " This API version has been deprecated." : "")
                    });
                options.CustomOperationIds(apiDesc =>
                {
                    apiDesc.TryGetMethodInfo(out MethodInfo methodInfo);
                    string controller = apiDesc.ActionDescriptor.RouteValues["controller"];
                    string methodName = methodInfo.Name;
                    return $"{controller}_{methodName}".Replace("Async", "", StringComparison.InvariantCultureIgnoreCase);
                });
            }
        }
    }
}