using Asp.Versioning;
using Asp.Versioning.ApiExplorer;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.OpenApi.Models;
using NetTopologySuite.Geometries;
using SOS.Lib.ActionFilters;
using SOS.Lib.Swagger;
using SOS.Observations.Api.Helpers;
using Swashbuckle.AspNetCore.SwaggerUI;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace SOS.Observations.Api.Extensions;

public static class SwaggerExtensions
{
    const string InternalApiName = "InternalSosObservations";
    const string PublicApiName = "PublicSosObservations";
    const string AzureInternalApiName = "AzureInternalSosObservations";
    const string AzurePublicApiName = "AzurePublicSosObservations";
    const string InternalApiPrefix = "Internal";
    const string AzureApiPrefix = "Azure";

    public static IServiceCollection SetupSwagger(this IServiceCollection services)
    {
        services.AddApiVersioning(options =>
        {
            options.DefaultApiVersion = new ApiVersion(1, 5);
            options.AssumeDefaultVersionWhenUnspecified = true;
            options.ReportApiVersions = true;
            options.ApiVersionReader = new HeaderApiVersionReader("X-Api-Version");
        }).AddApiExplorer(options =>
        {
            // add the versioned api explorer, which also adds IApiVersionDescriptionProvider service
            // note: the specified format code will format the version as "'v'major[.minor][-status]"
            options.GroupNameFormat = "'v'VV";
            // note: this option is only necessary when versioning by url segment. the SubstitutionFormat
            // can also be used to control the format of the API version in route templates
            options.SubstituteApiVersionInUrl = true;
        });


        services.AddSwaggerGen(
            options =>
            {
                options.MapType<Geometry>(() => new OpenApiSchema { Type = "object" });

                // add a custom operation filters
                options.OperationFilter<SwaggerDefaultValues>();
                options.OperationFilter<SwaggerAddOptionalHeaderParameters>();

                var currentAssembly = Assembly.GetExecutingAssembly();
                var xmlDocs = currentAssembly.GetReferencedAssemblies()
                    .Union(new AssemblyName[] { currentAssembly.GetName() })
                    .Select(a => Path.Combine(Path.GetDirectoryName(currentAssembly.Location), $"{a.Name}.xml"))
                    .Where(f => File.Exists(f)).ToArray();

                Array.ForEach(xmlDocs, (d) =>
                {
                    options.IncludeXmlComments(d);
                });

                options.SchemaFilter<SwaggerIgnoreFilter>();
                options.SchemaFilter<SwaggerForceSchemaFilter>();
                // Post-modify Operation descriptions once they've been generated by wiring up one or more
                // Operation filters.
                options.OperationFilter<ApiManagementDocumentationFilter>();

                options.DocInclusionPredicate((documentName, apiDescription) =>
                {
                    var apiVersions = StartupHelpers.GetApiVersions(apiDescription);
                    var versionMatch = apiVersions.Any(v => $"{InternalApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{PublicApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{AzureInternalApiName}v{v}" == documentName) 
                        || apiVersions.Any(v => $"{AzurePublicApiName}v{v}" == documentName);
                    var isAzurePublicApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(AzureApiAttribute));
                    var isAzurePublicDocument = documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase) && !documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase);
                    var isAzureInternalApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(AzureInternalApiAttribute));
                    var isAzureInternalDocument = documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase) && documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase);
                    var isInternalApi = apiDescription.ActionDescriptor.EndpointMetadata.Any(x => x.GetType() == typeof(InternalApiAttribute));
                    var isInternalDocument = documentName.Contains(InternalApiPrefix, StringComparison.CurrentCultureIgnoreCase) && !documentName.Contains(AzureApiPrefix, StringComparison.CurrentCultureIgnoreCase);

                    return
                        versionMatch && (
                            (isAzurePublicApi && isAzurePublicDocument) ||
                            (isAzureInternalApi && isAzureInternalDocument)
                        ) || (
                        !isAzurePublicDocument && !isAzureInternalDocument &&
                        (isInternalDocument || !isInternalApi)
                    );
                });

                options.AddSecurityDefinition("Bearer", //Name the security scheme
                    new OpenApiSecurityScheme
                    {
                        Name = "Authorization",
                        Description = "JWT Authorization header using the Bearer scheme.",
                        In = ParameterLocation.Header,
                        Type = SecuritySchemeType.Http, //We set the scheme type to http since we're using bearer authentication
                        Scheme = "bearer" //The name of the HTTP Authorization scheme to be used in the Authorization header. In this case "bearer".
                    });

                options.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme{
                            Scheme = "bearer",
                            Name = "Bearer",
                            In = ParameterLocation.Header,
                            Reference = new OpenApiReference{
                                Id = "Bearer", //The name of the previously defined security scheme.
                                Type = ReferenceType.SecurityScheme
                            }
                        },
                        new List<string>()
                    }
                });
            });

        return services;
    }

    public static WebApplication ApplyUseSwaggerUI(this WebApplication app)
    {
        var apiVersionDescriptionProvider = app.Services.GetRequiredService<IApiVersionDescriptionProvider>();
        app.UseSwaggerUI(options =>
        {
            foreach (var description in apiVersionDescriptionProvider.ApiVersionDescriptions)
            {
                options.SwaggerEndpoint(
                    $"/swagger/{InternalApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Internal) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                    $"/swagger/{PublicApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Public) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                   $"/swagger/{AzureInternalApiName}{description.GroupName}/swagger.json",
                   $"SOS Observations API (Internal - Azure) {description.GroupName.ToUpperInvariant()}");

                options.SwaggerEndpoint(
                    $"/swagger/{AzurePublicApiName}{description.GroupName}/swagger.json",
                    $"SOS Observations API (Public - Azure) {description.GroupName.ToUpperInvariant()}");

                options.DisplayOperationId();
                options.DocExpansion(DocExpansion.None);
            }
        });

        return app;
    }
}